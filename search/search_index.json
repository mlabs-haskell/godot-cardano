{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cardano Game Engine Wallet - Godot Integration","text":"<p>Cardano Game Engine Wallet is an integrated light wallet and off-chain SDK for the Godot engine and Cardano blockchain. The project is currently a work-in-progress.</p> <p>This project was publicly funded by the Cardano community in round 10 of Project Catalyst. Thank you for your support!</p>"},{"location":"#status","title":"Status","text":"<p>The project currently consists of a small demo that showcases two features:</p> <ul> <li>Generating / importing a wallet by entering a seed-phrase</li> <li>Transferring ADA to an arbitrary Cardano address.</li> </ul> <p>At the momment, the demo runs on the preview testnet and was tested on Linux and Windows x86-64 PCs.</p>"},{"location":"#how-to-build-and-run-the-demo-with-godot","title":"How to build and run the demo with Godot","text":""},{"location":"#pre-requisites","title":"Pre-requisites","text":"<ul> <li> <p>Godot Engine 4.2: The demo runs on version 4.2 of the Godot engine, which you   can download at the official website.</p> </li> <li> <p>A wallet with funds in the Cardano preview testnet: You can use any wallet you like, as   long as it supports the preview testnet. Take note of the seed-phrase of your wallet. To get test ADA (tADA), use the Cardano testnet faucet.</p> </li> <li> <p>A Blockfrost token: Our demo uses Blockfrost as a provider for querying the blockchain and submitting transactions. You will need a Blockfrost account and a preview testnet token.</p> </li> </ul>"},{"location":"#setup","title":"Setup","text":"<p>First, clone the repository and enter the top directory.</p> <pre><code>$ git clone https://github.com/mlabs-haskell/godot-cardano.git\n$ cd godot-cardano\n</code></pre> <p>Download <code>godot-cardano.zip</code> from the releases page, unzip it and copy the <code>addons</code> folder into the <code>demo</code> folder of the repo.</p> <pre><code>$ curl https://github.com/mlabs-haskell/godot-cardano/releases/download/release-.../godot-cardano.zip -O godot-cardano.zip\n$ unzip godot-cardano.zip -o demo\n</code></pre> <p>Inside the <code>demo</code> folder, create a \"preview_token.txt\" file with your Blockfrost preview token.</p> <pre><code>$ echo \"&lt;YOUR TOKEN&gt;\" &gt; demo/preview_token.txt\n</code></pre> <p>Open the Godot editor. You will be greeted by the Project Manager. Import and open the project located in the <code>demo</code> folder.</p> <p></p> <p></p> <p>You should now have the Godot editor window with the project loaded. Press the button for running the current scene (or press <code>F5</code>).</p> <p></p>"},{"location":"#how-the-demo-works","title":"How the demo works","text":"<p>The demo consists of two forms:</p> <ol> <li>A form for filling in the wallet's mnemonic phrase</li> <li>A form for transferring ADA to an arbitrary address</li> </ol> <p>The two forms must be filled in sequence.</p> <ol> <li> <p>First fill in the seed phrase of the wallet specified in the Pre-requisites section.</p> </li> <li> <p>Click on \"Set wallet\". If the wallet is loaded correctly, the demo should inform you of the amount of UTxOs found in the address associated to that wallet (as well as the amount of funds in it).</p> </li> <li> <p>Set the recipient address of the transaction (you may use the address of your wallet if you want).</p> </li> <li> <p>Fill in the amount of lovelace to send. A reminder that lovelace is the smallest unit of ADA currency: 1 ADA = 1,000,000 lovelace. You should send at least 969,750. This is the smallest value a UTxO may have in Cardano, any less will trigger a runtime error.</p> </li> <li> <p>Click on \"Send ADA\". This will use the Blockfrost backend to submit the transaction to the Cardano blockchain.</p> </li> </ol> <p></p> <p>At this point the demo is over. The demo will not inform you of the success of the transaction, but you may use any tool to confirm that a transaction occurred between your wallet and the recipient.</p> <p>For instance, here we use Cardanoscan (Preview) to monitor the wallet address and confirm that a transaction occurred:</p> <p></p>"},{"location":"#whats-next","title":"What's next?","text":"<p>Check our milestones here!</p> <p>You may also read our Proof Of Achievement / Research report written for the milestone as well. This document discusses our work and rationale for the technical decisions we have made.</p>"},{"location":"#development","title":"Development","text":"<p>Development is supported on linux. On other platforms, use a virtual machine or WSL. To get started, clone the repo and enter it.</p>"},{"location":"#setup_1","title":"Setup","text":"<p>Install Nix and enable flakes, or do it in one step with the Determinate nix installer.</p>"},{"location":"#build-asset","title":"Build Asset","text":"<pre><code>$ nix build .#godot-cardano\n</code></pre>"},{"location":"#build-and-run-demo","title":"Build and Run Demo","text":"<pre><code>$ nix build .#demo\n$ nix run .#steam-run result/bin/demo\n</code></pre>"},{"location":"#run-integration-test-on-preview-network","title":"Run Integration Test on preview network","text":"<p>Before running the tests, ensure that <code>test/preview_token.txt</code> is populated with a valid Blockfrost preview key, and that <code>test/seed_phrase.txt</code> is populated with a valid 24-word seed phrase and the address is funded with testnet ADA from the faucet. Alternatively, your seed phrase can be set via the <code>TESTNET_SEED_PHRASE</code> environment variable. The address used will be the default address in most light wallets, as well as in the demo app provided with this project. Once these are set, run the test suite:</p> <p>Run integration test on preview network.</p> <pre><code>$ nix run .#preview-integration-test\n</code></pre>"},{"location":"#development-shell","title":"Development shell","text":"<p>Enter development shell with all dependencies in PATH and addons linked. A list of useful commands is displayed.</p> <pre><code>$ nix develop\n\ud83d\udd28 Welcome to godot-cardano devshell\n\n[[general commands]]\ncardano-cli - The Cardano command-line interface\n\n...\n</code></pre> <p>Here are some useful workflows inside the development shell:</p>"},{"location":"#build-the-godot-extension","title":"Build the Godot extension","text":"<pre><code>$ cd libcsl_godot\n$ cargo build\n$ ls target/debug/libcsl_godot.so\n$ ls -la ../addons/@mlabs-haskell/godot-cardano/bin/\n</code></pre>"},{"location":"#open-the-demo-app-in-godot-editor","title":"Open the demo app in Godot editor","text":"<pre><code>$ cd demo\n$ echo \"&lt;your bockfrost preview token&gt;\" &gt; preview_token.txt\n$ godot4 --editor\n</code></pre> <p>With the <code>demo</code> or <code>test</code> project open, the Godot editor should automatically reload the gdextension after <code>cargo build</code>.</p>"},{"location":"#export-and-run-the-demo","title":"Export and run the demo","text":"<pre><code>$ cd demo\n$ godot4 --headless --export-debug  \"Linux/X11\" out/demo project.godot\n$ steam-run out/demo\n</code></pre>"},{"location":"#run-integration-tests-on-preview-network","title":"Run integration tests on preview network","text":"<pre><code>$ cd test\n$ godot4 --headless --script addons/gut/gut_cmdln.gd\n</code></pre>"},{"location":"#start-private-testnet-and-fund-wallet","title":"Start private testnet and fund wallet","text":"<pre><code>$ overmind start -D\n$ private-testnet-fund-ada\n$ echo $PRIVATE_TESTNET_PAYMENT_ADDRESS\n$ echo $PRIVATE_TESTNET_PAYMENT_VKEY\n$ echo $PRIVATE_TESTNET_PAYMENT_SKEY\n$ overmind quit\n</code></pre>"},{"location":"Shop%20Tutorial/","title":"Shop tutorial","text":""},{"location":"Shop%20Tutorial/#introduction","title":"Introduction","text":""},{"location":"Shop%20Tutorial/#overview","title":"Overview","text":"<p>godot-cardano is a Software Development Kt (SDK) for developing Cardano applications within the Godot engine. The framework is aimed at game developers looking to build decentralized games making use of the Cardano ledger, Cardano native tokens (CNTs), and the Plutus smart contract language. The SDK is distributed as an add-on including a binary library built with Cardano Serialization Lib and Aiken, and a collection of GDScript classes, which can be downloaded together from the releases page of the GitHub repository.</p> <p>The SDK provides a framework similar to Lucid with which developers can create Cardano wallets for users, query the ledger state, send and receive ADA and CNTs, and employ Plutus scripts for locking and minting assets.</p> <p>godot-cardano puts particular emphasis on developing decentralized games by enabling developers to build and evaluate transactions entirely within the Godot engine and the provided library, as well as by providing an interface for configuring, minting and spending CNTs based on the CIP68 metadata standard.</p> <p>This document aims to introduce developers to the features of the framework mentioned above by working through an example, the code for which is provided in full in the GitHub repository as the <code>shop-demo</code> project. The example itself is too long to be presented in its entirety, so the document is split into four sections: the first three dealing with the main concepts and classes, and the last dealing with how to initialize the main components.</p> <p>This document assumes some familiarity with Cardano and the \u201ceUTXOma\u201d ledger it uses (Extended, Multi-Asset UTxO model). For this reason, it is not a good introduction to the Cardano blockchain and its scripting capabilities and concepts (validators, minting policies, redeemers, datums, etc). It also assumes some basic knowledge of the Godot engine, so it might be a good idea to at least know the basic building blocks of the engine (Scenes, Nodes, Signals, the game loop).</p>"},{"location":"Shop%20Tutorial/#the-shop-demo","title":"The shop demo","text":"<p>The demo provides a simple interface that allows the user to trade CNTs for ADA with a Plutus smart contract using their wallet. The tokens in the demo use the CIP68 standard to encode example properties (in this case, three metadata values encoding their RGB color, and their price as Plutus data) which can be used as an example for any properties that might be needed for the purposes of a game. The demo and the scripts provided have been manually tested on Cardano's Preview testnet, but are not recommended for use on Mainnet.</p> <p>The shop contract provided will validate the exchange of tokens for ADA based on the price encoded in the datum and may be used as an example of how to allow for permissionless exchanges of CIP68 tokens, which may represent (for example) items or characters in your game.</p> <p>The interface presents a shop displaying the items available for sale, along with the user's current assets in the bottom right corner. The inventory button next to the user's funds allows to user to view and sell the current items in their wallet.</p> <p></p> <p></p> <p>Before running the shop demo, you will need to procure an API token from Blockfrost and save it in <code>shop-demo/preview_token.txt</code>. By default the demo will be configured to use the Preview network. On the first run of the demo, the application will generate a new wallet and print the address to the Godot console. You will need to fund this address with tADA from the testnet faucet.</p>"},{"location":"Shop%20Tutorial/#transactions-in-the-demo","title":"Transactions in the demo","text":"<p>The two primary transactions used in the demo are the minting and buying transactions.</p> <p>The minting transaction involves a Plutus minting policy and various CIP68 configurations which will be used to mint the CNTs in the ledger and send them to the shop. Note that the minting policy provided offers no protection against, for example, duplicate minting of non-fungible tokens or arbitrary burning. As such, the only requirements for this transaction are the tADA needed for the transaction fee and the minimum tADA needed to populate the reference and shop UTxOs.</p> <p>The buying/selling transaction requires a shop input, which may be queried from the ledger using the script's payment credential, and the reference inputs for any tokens you wish to trade, which require querying for the correct reference tokens. The shop script also requires exactly one shop output which ensures that the difference in CNTs versus the input is reflected inversely in the difference in ADA based on the price specified by the datum attached to the reference token.</p> <p>The <code>TxBuilder</code> will use the loaded wallet to get the user's UTxOs for balancing the transaction and select inputs that will allow it to complete the transaction.</p> <p>All scripts used in the demo are provided in the GitHub repository under <code>scripts</code>.</p>"},{"location":"Shop%20Tutorial/#wallets","title":"Wallets","text":""},{"location":"Shop%20Tutorial/#the-two-types-of-wallet","title":"The two types of wallet","text":"<p>The SDK provides wallets in the form of <code>SingleAddressWallet</code> and <code>OnlineWallet</code>. Conceptually, a <code>SingleAddressWallet</code> is one example of a wallet that may be used to store keys, generate addresses, and sign transactions. An <code>OnlineWallet</code> is an augmented form of such a wallet that enables querying the ledger using the <code>Provider</code> class. Currently <code>SingleAddressWallet</code> is the only form of underlying wallet provided and its use is comparable to most Cardano light wallets.</p>"},{"location":"Shop%20Tutorial/#how-wallets-are-handled-in-the-demo","title":"How wallets are handled in the demo","text":"<p>In the demo, the wallet is loaded via a singleton class. This is chosen as a simple a example of how to initialize the user's wallet and allow it to persist between multiple scenes and is assumed to be the most general approach for a blockchain game. It also allows better management of queries by enabling caching, where loading a new wallet per scene may mean additional queries. Other approaches may still be preferred depending on the particular needs of a game.</p> <p>For the purposes of the demo, the user's password is simply hardcoded in-place as a string literal. This choice allows for a smoother demonstration, but is naturally not recommended for real-world use. It is recommended that your game require the user to select a sufficiently complex password to encrypt their private key on wallet creation, and to intermittently prompt the user for their password during the game. Depending on your game, it may also be acceptable to prompt the user for their password every time they sign a transaction.</p>"},{"location":"Shop%20Tutorial/#wallet-creation","title":"Wallet creation","text":"<p>Upon the first run of the demo, a wallet is generated using the function shown:</p> <pre><code>func create_new_wallet() -&gt; SingleAddressWallet:\nvar new_wallet_result := SingleAddressWalletLoader.create(\n\"1234\",\n0,\n\"My Account\",\n\"An account for my Cardano game\",\nnetwork\n)\nif new_wallet_result.is_err():\npush_error(\"Failed to create wallet: %s\" % new_wallet_result.error)\nreturn\nvar new_wallet := new_wallet_result.value.wallet\nResourceSaver.save(new_wallet.export(), wallet_path)\nreturn new_wallet\n</code></pre> <p>The parameters provided are, in order: the spending password, the account index, the account name, the account description and the network.</p> <ul> <li>The spending password is used to encrypt the account's private key on disk. Here we have chosen a trivial password, but it's recommended that you require the user to provide a password of a minimum 8 characters selected from a varied character set.</li> <li>The account index is the default account to select after creating the wallet. This is the same account index you will see in light wallets such as Eternl. In most cases you will simply want to select account 0, and new accounts may be added to the user's wallet later on.</li> <li>The account name and account description are provided for convenience to allow the developer to attach extra information to the user's wallet and accounts.</li> <li>The network is the selected Cardano network in the <code>WalletSingleton</code> and will be chosen as the Preview network by default.</li> </ul> <p>In this snippet we can also see our first example of the  <code>Result</code> type, which is used to present various errors from the packaged library. More information on this type can be found in the appendices.</p> <p>After generating a new wallet, you may want to present the user with the generated recovery phrase (<code>new_wallet_result.value.seedphrase</code>) to be written down. This phrase will be the only way to restore a wallet in the case of data loss or a forgotten password, and it allows full access to the assets in the user's wallet. As such this should be treated as highly-sensitive information and should be discarded shortly after generating the wallet, not written to disk or otherwise stored digitally. You may also want to give the user the opportunity to verify that they have correctly backed up their recovery phrase before continuing.</p> <p>It is recommended that users only restore wallets generated by and used with godot-cardano, and only in cases where it is strictly necessary to do so. For everyday use, the recovery phrase should be safely stored in handwritten form only. The password-encrypted wallet may be backed up from the Godot user data directory.</p>"},{"location":"Shop%20Tutorial/#wallet-saving-and-loading","title":"Wallet saving and loading","text":"<p>The wallet saved in the previous section may be loaded as follows:</p> <pre><code>func load_wallet() -&gt; SingleAddressWalletLoader.WalletImportResult:\nvar wallet_resource: SingleAddressWalletResource = load(wallet_path)\nvar loader = SingleAddressWalletLoader.new(network)\nreturn await loader.import_from_resource(wallet_resource)\n</code></pre> <p>Additionally, you may recover a lost wallet from the recovery phrase mentioned in the previous section using a function similar to the following:</p> <pre><code>func load_wallet_from_seedphrase(\nseed_phrase: String\n) -&gt; SingleAddressWalletLoader.WalletImportResult:\nvar loader := SingleAddressWalletLoader.new(ProviderApi.Network.PREVIEW)\nvar import_result := await loader.import_from_seedphrase(\nseed_phrase,\n\"\",\n\"1234\",\n0,\n\"My Account\",\n\"An account for my Cardano game\",\n)\nreturn import_result\n</code></pre> <p>These arguments are the same as the those for <code>SingleAddressWalletLoader.create</code>, with the exclusion of the network argument (which is provided to the loader instead) and an additional argument in the second position. This new argument is the BIP39 passphrase and is considered an advanced feature. It's recommended to leave this as the empty string unless you know what you are doing.</p>"},{"location":"Shop%20Tutorial/#providers","title":"Providers","text":""},{"location":"Shop%20Tutorial/#introduction_1","title":"Introduction","text":"<p>The <code>*Provider*</code> is the node used to query the current Cardano ledger state. It may be used to query data such as UTxOs at a given address or the parameters for current epoch. The <code>Provider</code> is how <code>OnlineWallet</code> communicates with the network, and is required for <code>TxBuilder</code> to be effective.</p> <p>The <code>Provider</code> depends on a backend called the <code>ProviderApi</code> to query network information. Currently, the only <code>ProviderApi</code> implemented is the <code>BlockfrostProviderApi</code>, but the developer may extend this class to use whatever backend is better suited to their application (e.g. Koios, Maestro, Kupo/Ogmios, Emulator).</p>"},{"location":"Shop%20Tutorial/#initialization","title":"Initialization","text":"<p>A <code>Provider</code> can be initialized as follows:</p> <pre><code>    var blockfrost_api_key = FileAccess.get_file_as_string(\"res://preview_token.txt\").strip_edges()\nvar provider_api := BlockfrostProviderApi.new(\nnetwork,\nblockfrost_api_key\n)\nadd_child(provider_api)\nprovider = Provider.new(provider_api)\nadd_child(provider)\n</code></pre> <p>Note that both the <code>ProviderApi</code> and <code>Provider</code> are added by the developer to the scene tree here. This will be required in order to perform HTTP requests, make use of <code>Timer</code>s, etc.</p> <p>In the demo we also enable caching and chaining in the <code>Provider</code>:</p> <pre><code>    provider.chain_address(wallet.get_address())\nprovider.use_chaining = true\nprovider.use_caching = true\n</code></pre> <p>Here we tell the <code>Provider</code> that we want to substitute known spent transaction outputs with produced unspent transaction outputs for the user's wallet, and that chaining and caching should both be used. Chaining is considered experimental and currently is only implemented for local transactions, but in the appropriate conditions this can greatly improve the user experience of your game.</p>"},{"location":"Shop%20Tutorial/#how-queries-are-used-in-the-shop-demo","title":"How queries are used in the shop demo","text":"<p>The demo uses the <code>Provider</code> to query for UTxOs at the reference lock address and the shop address:</p> <pre><code>    var shop_utxos := await provider.get_utxos_at_address(\nprovider.make_address(Credential.from_script_source(shop_script_source))\n)\nvar ref_utxo := await provider.get_utxo_with_nft(\nconf.make_ref_asset_class()\n)\n</code></pre> <p>In this example we also see the <code>Provider</code> being used to generate an address from the shop script's payment credential, and the reference asset class being generated from a <code>Cip68Config</code>. <code>Provider.make_address</code> may also be provided with an additional credential used for staking any ADA sent to the generated address. Most queries performed by the developer will likely resemble one of these two, while other queries may be performed implicitly via other components of the framework.</p>"},{"location":"Shop%20Tutorial/#transactions","title":"Transactions","text":""},{"location":"Shop%20Tutorial/#overview-of-transaction-building-signing-and-submitting","title":"Overview of transaction building, signing and submitting","text":"<p>Transactions are typically handled by the developer in three main steps:</p> <ol> <li>Creating the <code>TxBuilder</code> via the <code>OnlineWallet</code></li> <li>Building the transaction by adding constraints with <code>TxBuilder</code></li> <li>Signing and submitting the transaction with <code>TxComplete</code></li> </ol> <p>In the first step, <code>Wallet.new_tx</code> is used to generate a new <code>TxBuilder</code>. This will immediately return a success status in the form of a <code>TxBuilder.CreateResult</code>. It's also possible to create a transaction through <code>Provider.new_tx</code>, and this may be useful in cases where you want the transaction to be generated for a wallet that is not local.</p> <p>In the second step, constraints are added to the <code>TxBuilder</code> through various methods, and these will be used to build the final transaction with <code>TxBuilder.complete</code>:</p> <pre><code>func complete(utxos: Array[Utxo] = []) -&gt; CompleteResult:\n</code></pre> <p>This is where the transaction is balanced and evaluated. In the case where the <code>TxBuilder</code> was created without a wallet, you will need to provide <code>utxos</code> for balancing. These can be created manually with <code>Utxo.create</code> if needed.</p> <p>In the third step, signatures are added to the transaction through <code>TxComplete.sign</code>:</p> <pre><code>func sign(password: String, wallet: OnlineWallet = _wallet) -&gt; TxComplete:\n</code></pre> <p>For this last step, you may instead use <code>TxComplete.bytes</code> to obtain a transaction as a <code>PackedByteArray</code>, which can then be signed and submitted elsewhere.</p> <p>In the second and third steps, errors are collected and reported on finalization: Upon calling <code>TxBuilder.complete</code> or <code>TxComplete.submit</code>, any encountered errors will be logged to the Godot console and the <code>Result</code> will indicate an error.</p>"},{"location":"Shop%20Tutorial/#using-with_tx-to-reduce-the-boilerplate","title":"Using <code>with_tx</code> to reduce the boilerplate","text":"<p>Since this sequence of steps is normally repeated for any given transaction, you may use instead <code>OnlineWallet.with_tx</code> (or <code>Provider.with_tx</code>) to automate most of it. These functions take two callbacks:</p> <ol> <li>A function that receives a <code>TxBuilder</code> and adds any desired constraints to the transaction</li> <li>A function that receives <code>TxComplete</code> and adds any required signatures.</li> </ol> <p>Using <code>with_tx</code> can be convenient because it removes boilerplate and the need to introduce variables into the local scope. The main setback is that it does not provide as much flexibility for handling errors and submitting transactions: on success it will submit the transaction automatically. On failure, the errors will be logged to the Godot console and the function will return <code>null</code>.</p>"},{"location":"Shop%20Tutorial/#building-transactions","title":"Building transactions","text":"<p>Now that we explained the general process that must be followed for all transactions, we will explain in more detail the first step: transaction building.</p> <p>Like most Cardano frameworks, godot-cardano uses a constraints system that allows a user to succinctly define transactions without specifying the whole transaction object. This system is mostly inherited from the underlying Cardano Serialization Library (CSL) that the framework uses, but it also takes inspiration from the Lucid framework.</p> <p>Transactions are very complex objects in Cardano, with many fields that are interrelated. If we tried to set values for these fields manually, we would quickly find that it easy to create malformed transactions that fail verification upon submission.</p> <p>For this reason, it is only common sense to define them by setting constraints the TX must follow, and letting the framework build a transaction that satisfy them (or fail if it is not possible!).</p> <p>This approach is not without its disadvantages, though: to keep the number of constraints in a manageable level, some implicit defaults must be set. These should be learnt in order to understand the final transaction obtained (e.g: any change is by default sent back to the wallet generating the transaction, minted assets are by default placed in the address of the minting wallet, etc). However, you will find that the defaults are quite reasonable and should not lead to surprises.</p> <p>We can see an example of adding constraints in <code>mint_tokens</code>. All constraints are implemented as methods of the <code>TxBuilder</code> class:</p> <pre><code>func mint_tokens() -&gt; bool:\nbusy = true\nvar shop_address := provider.make_address(\nCredential.from_script_source(shop_script_source)\n)\nvar new_tx_result := await wallet.new_tx()\nif new_tx_result.is_err():\npush_error(\"Could not create transaction: %s\" % new_tx_result.error)\nreturn false\nvar tx_builder := new_tx_result.value\nvar new_mint := false\nfor conf in cip68_data:\nvar asset_class := conf.make_ref_asset_class()\nvar utxo := await provider.get_utxo_with_nft(asset_class)\nif utxo == null:\nnew_mint = true\ntx_builder.mint_cip68_pair(VoidData.to_data(), conf)\ntx_builder.pay_cip68_ref_token(\nprovider.make_address(\nCredential.from_script_source(ref_lock_source),\n),\nconf\n)\ntx_builder.pay_cip68_user_tokens_with_datum(\nshop_address,\nPlutusBytes.new(owner_pub_key_hash.to_bytes()),\nconf\n)\nif not new_mint:\nreturn false\nvar complete_result := await tx_builder.complete()\nif complete_result.is_err():\npush_error(\"Failed to build transaction: %s\" % complete_result.error)\nreturn false\nvar tx := complete_result.value\ntx.sign(\"1234\")\nvar submit_result := await tx.submit()\nif submit_result.is_err():\npush_error(\"Failed to submit transaction: %s\" % submit_result.error)\nreturn false\nprovider.invalidate_cache()\nupdate_timer.timeout.emit()\nprint(\"Minted; tx hash: %s\" % submit_result.value.to_hex())\nbusy = false\nreturn true\n</code></pre> <p>Here we are:</p> <ul> <li>Adding a minting constraint: <code>mint_cip68_pair</code> makes sure that the generated TX mints a valid pair of CIP68 tokens (in this case, one reference token and multiple fungible user tokens).</li> <li>Adding two paying constraints: <code>pay_cip68_ref_token</code> sets the destination address of the reference token to the ref lock script. <code>pay_cip68_user_tokens_with_datum</code> sets the destination address of the user tokens to the shop script, while also specifying the datum the output should have (the owner\u2019s PubKeyHash). Notice that the first constraint conveniently sets the datum of the reference token: this is necessary for any CIP68 reference token, so it is handled automatically.</li> </ul> <p>This function should also be a good example of all the points at which errors may be reported via <code>Result</code>s in the process of building, signing, and submitting a transaction.</p> <p>Some other examples of constraints available via the <code>TxBuilder</code> include:</p> <pre><code>func set_change_address(change_address: Address) -&gt; TxBuilder:\nfunc valid_after(time: int) -&gt; TxBuilder:\nfunc valid_before(time: int) -&gt; TxBuilder:\nfunc add_required_signer(pub_key_hash: PubKeyHash) -&gt; TxBuilder:\nfunc add_reference_input(utxo: Utxo) -&gt; TxBuilder:\n</code></pre> <p>You can always consult the documentation for these methods to learn more about how they affect the transaction being built.</p>"},{"location":"Shop%20Tutorial/#script-spendingminting-transactions","title":"Script Spending/Minting Transactions","text":"<p>Plutus scripts may be loaded in various ways. We provide the <code>ScriptResource</code> and its child classes for convenience. These include</p> <ul> <li><code>ScriptFromBlueprint</code>, which loads a script from a CIP57 blueprint file given a filename and a validator name.</li> <li><code>ScriptFromOutRef</code>, which loads a script by querying the provided transaction output reference and reading the script attached to the UTxO. This can greatly reduce transaction sizes, but requires you to deploy the script to the ledger and keep a handle of the output reference.</li> <li><code>ScriptFromCborHex</code>, which simply loads a script directly from hex-encoded CBOR.</li> </ul> <p>The <code>ScriptResource.load_script</code> method can be used to obtain a <code>PlutusScriptSource</code>, which can then be used to generate addresses and asset classes used for querying, as well as being given to various <code>TxBuilder</code> constraints to later be used in evaluation. Examples of generating query arguments are as follows:</p> <pre><code>    var ref_lock_utxos = await provider.get_utxos_at_address(\nprovider.make_address(Credential.from_script_source(ref_lock_source))\n)\n</code></pre> <pre><code>    return AssetClass.new(\nPolicyId.from_script_source(script_source),\ntoken_name\n)\n</code></pre> <p>To deploy a script to a UTxO in order to use it as a reference script in future, you can extract the <code>PlutusScript</code> from non-ref <code>ScriptResource</code>s and provide this as the optional <code>script_ref</code> argument of <code>TxBuilder.pay_to_address</code>. An example of this is provided as part of the demo:</p> <pre><code>func load_script_and_create_ref(filename: String) -&gt; PlutusScriptSource:\nvar source := await provider.load_script(\nload_user_or_res(\"cip68_data/%s\" % filename) as ScriptResource\n)\nif not source.is_ref():\nvar tx_hash := await wallet.tx_with(\nfunc(tx_builder: TxBuilder):\ntx_builder.pay_to_address(\nprovider.make_address(\nCredential.from_script_source(ref_lock_source)\n),\nBigInt.zero(),\nMultiAsset.empty(),\nVoidData.to_data(),\nsource.script()\n),\nfunc (tx: TxComplete):\ntx.sign(\"1234\")\n)\nif tx_hash != null:\nvar res := ScriptFromOutRef.new(tx_hash, 0)\nawait provider.await_tx(tx_hash)\nResourceSaver.save(res, \"user://cip68_data/%s\" % filename)\nsource = await provider.load_script(res)\nreturn source\n</code></pre> <p>In addition, you can provide a <code>ScriptResource</code> as the \"Minting Policy\" field of a <code>Cip68Config</code> resource and (after calling <code>Cip68Config.init_script</code>) allow the <code>TxBuilder</code> to handle the script requirements with the CIP68 helper methods provided. This usage can be seen in the demo under <code>res://cip68_data/</code>. The helper functions include:</p> <pre><code>func mint_cip68_pair(redeemer: PlutusData, conf: Cip68Config) -&gt; TxBuilder:\nfunc mint_cip68_user_tokens(\nredeemer: PlutusData,\nconf: Cip68Config,\nquantity := conf.get_quantity()\n) -&gt; TxBuilder:\nfunc pay_cip68_ref_token(address: Address, conf: Cip68Config) -&gt; TxBuilder:\nfunc pay_cip68_user_tokens(\naddress: Address,\nconf: Cip68Config,\nquantity := conf.get_quantity()\n) -&gt; TxBuilder:\nfunc pay_cip68_user_tokens_with_datum(\naddress: Address,\ndatum: PlutusData,\nconf: Cip68Config,\nquantity := conf.get_quantity()\n) -&gt; TxBuilder:\n</code></pre> <p>The scripts provided in the demo each take a tag argument used to generate unique addresses and policy IDs. You can generate a unique shop of which your wallet is the owner by changing the tag to a number that has not yet been used. This tag can be found in the demo as <code>res://cip68_data/scripts_tag.tres</code></p>"},{"location":"Shop%20Tutorial/#script-evaluation","title":"Script evaluation","text":"<p>In general, <code>TxBuilder.complete</code> is the correct way to finalize a transaction by balancing and evaluating it, but in cases of script validation failure you may want to instead use <code>TxBuilder.balance</code> to obtain a balanced transaction before evaluation. This can be examined for diagnostic purposes but should not be treated as a completed transaction to be signed or submitted, as doing so could potentially mean losing the provided collateral.</p>"},{"location":"Shop%20Tutorial/#building-the-buysell-transactions-in-the-demo","title":"Building the buy/sell transactions in the demo","text":"<p>For building the buy/sell transaction, we use <code>OnlineWallet.tx_with</code> :</p> <pre><code>    var tx_hash := await wallet.tx_with(\nfunc (tx_builder: TxBuilder):\ntx_builder.collect_from_script(\nshop_script_source,\n[selected_utxo],\nVoidData.to_data()\n)\ntx_builder.add_reference_input(ref_utxo)\ntx_builder.pay_to_address(\nWalletSingleton.provider.make_address(\nCredential.from_script_source(shop_script_source)\n),\nselected_utxo.coin().add(\nBigInt.from_int(conf.extra_plutus_data.data.to_int() * quantity\n)),\nassets,\nshop_datum\n),\nfunc (tx: TxComplete):\ntx.sign(\"1234\")\n)\n</code></pre> <p>Here we provide <code>wallet.tx_with</code> with two <code>Callable</code>s: one for building the transaction, and one for signing it.</p> <p>The constraints used are:</p> <ul> <li><code>collect_from_script</code>: This is a spending constraint, it consumes the unspent output containing the user tokens. Since it\u2019s locked by a Plutus script, the script and the redeemer are required parameters. It is worth nothing that this output is spent regardless of the transaction being a sale or a purchase of tokens: an output will be created at the validator any way and the validator will make sure that the amount of user tokens at the end follows the purchase/sale formula.</li> <li><code>add_reference_input</code>: This constraint adds the unspent output with the reference token (which contains the price of the user token) as a reference input to the transaction. This input is not consumed, but it is required nonetheless by the validator to make sure the user is paying/getting paid according to the token\u2019s established price.</li> <li><code>pay_to_address</code>: As expected, a paying constraint is added to send user tokens back to the validator. This will include the amount of user tokens spent from the validator plus the difference of user tokens sold/purchased. It will also include the amount of ADA required by the price and amount of tokens exchanged.</li> </ul> <p>As can be seen above, purchases and sales can be handled uniformly by using three simple constraints and an appropriate formula.</p>"},{"location":"reference/Abstract/","title":"Abstract","text":""},{"location":"reference/Abstract/#abstract","title":"Abstract","text":"<p>Extends: RefCounted</p>"},{"location":"reference/Abstract/#description","title":"Description","text":"<p>Used to represent abstract classes which should never be instantiated. Concrete classes inheriting from this class should always override [method Abstract._init].</p> <p>Used to represent abstract classes which should never be instantiated. Concrete classes inheriting from this class should always override [method Abstract._init].</p>"},{"location":"reference/Account/","title":"Account","text":""},{"location":"reference/Account/#account","title":"Account","text":"<p>Extends: RefCounted</p>"},{"location":"reference/Account/#description","title":"Description","text":"<p>An Account.</p> <p>An Account.</p>"},{"location":"reference/Account/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Account/#_init","title":"_init","text":"<pre><code>func _init(account: _Account) -&gt; Account\n</code></pre>"},{"location":"reference/AccountResource/","title":"AccountResource","text":""},{"location":"reference/AccountResource/#accountresource","title":"AccountResource","text":"<p>Extends: Resource</p>"},{"location":"reference/AccountResource/#description","title":"Description","text":"<p>This is a storage class used in [method SingleAddressWalletLoader.export].</p> <p>This is a storage class used in [method SingleAddressWalletLoader.export].</p>"},{"location":"reference/AccountResource/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/AccountResource/#index","title":"index","text":"<pre><code>@export var index: int\n</code></pre>"},{"location":"reference/AccountResource/#name","title":"name","text":"<pre><code>@export var name: String\n</code></pre>"},{"location":"reference/AccountResource/#description_1","title":"description","text":"<pre><code>@export var description: String\n</code></pre>"},{"location":"reference/AccountResource/#public_key","title":"public_key","text":"<pre><code>@export var public_key: PackedByteArray\n</code></pre>"},{"location":"reference/AssetClass/","title":"AssetClass","text":""},{"location":"reference/AssetClass/#assetclass","title":"AssetClass","text":"<p>Extends: RefCounted</p>"},{"location":"reference/AssetClass/#description","title":"Description","text":""},{"location":"reference/AssetClass/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/AssetClass/#_init","title":"_init","text":"<pre><code>func _init(policy_id: PolicyId, asset_name: AssetName) -&gt; AssetClass\n</code></pre>"},{"location":"reference/AssetClass/#to_unit","title":"to_unit","text":"<pre><code>func to_unit() -&gt; String\n</code></pre> <p>Convert the AssetClass.</p>"},{"location":"reference/AssetClass/#from_unit-static","title":"from_unit (static)","text":"<pre><code>func from_unit(asset_unit: String) -&gt; FromUnitResult\n</code></pre> <p>Try to parse an AssetClass hex encodings.</p>"},{"location":"reference/AssetClass/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/AssetClass/#fromunitresult","title":"FromUnitResult","text":""},{"location":"reference/AssetClass/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/AssetClass/#value","title":"value","text":"<pre><code>var value: AssetClass\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_ok</code>.</p>"},{"location":"reference/AssetClass/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_err</code>.</p>"},{"location":"reference/AssetClass/#method-descriptions_1","title":"Method Descriptions","text":""},{"location":"reference/AssetClass/#_init_1","title":"_init","text":"<pre><code>func _init(results: ArrayResult) -&gt; FromUnitResult\n</code></pre>"},{"location":"reference/AssetName/","title":"AssetName","text":""},{"location":"reference/AssetName/#assetname","title":"AssetName","text":"<p>Extends: RefCounted</p>"},{"location":"reference/AssetName/#description","title":"Description","text":"<p>An AssetName (or currency symbol).</p> <p>An AssetName (or currency symbol).</p>"},{"location":"reference/AssetName/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/AssetName/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, COULD_NOT_DECODE_HEX = 1}\n</code></pre>"},{"location":"reference/AssetName/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/AssetName/#_init","title":"_init","text":"<pre><code>func _init(asset_name: _AssetName) -&gt; AssetName\n</code></pre>"},{"location":"reference/AssetName/#to_bytes","title":"to_bytes","text":"<pre><code>func to_bytes() -&gt; PackedByteArray\n</code></pre>"},{"location":"reference/AssetName/#to_hex","title":"to_hex","text":"<pre><code>func to_hex() -&gt; String\n</code></pre> <p>Get the hex encoding of the AssetName.</p>"},{"location":"reference/AssetName/#from_hex-static","title":"from_hex (static)","text":"<pre><code>func from_hex(hash: String) -&gt; FromHexResult\n</code></pre> <p>Try to parse an [class AssetName] from [param hash] containing its hex encoding.</p>"},{"location":"reference/AssetName/#from_bytes-static","title":"from_bytes (static)","text":"<pre><code>func from_bytes(bytes: PackedByteArray) -&gt; FromBytesResult\n</code></pre> <p>Try to parse an AssetName.</p>"},{"location":"reference/AssetName/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/AssetName/#fromhexresult","title":"FromHexResult","text":""},{"location":"reference/AssetName/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/AssetName/#value","title":"value","text":"<pre><code>var value: AssetName\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/AssetName/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/AssetName/#frombytesresult","title":"FromBytesResult","text":""},{"location":"reference/AssetName/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/AssetName/#value_1","title":"value","text":"<pre><code>var value: AssetName\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/AssetName/#error_1","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/BigInt/","title":"BigInt","text":""},{"location":"reference/BigInt/#bigint","title":"BigInt","text":"<p>Extends: PlutusData &lt; Resource</p>"},{"location":"reference/BigInt/#description","title":"Description","text":"<p>This class is used for representing both positive and negative integers of arbitrary size.  You should not create a BigInt(BigInt) to get those numbers.</p> <p>This class is used for representing both positive and negative integers of arbitrary size.  You should not create a BigInt(BigInt) to get those numbers.</p>"},{"location":"reference/BigInt/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/BigInt/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, COULD_NOT_PARSE_BIGINT = 1, COULD_NOT_DESERIALIZE_BIGINT = 2}\n</code></pre>"},{"location":"reference/BigInt/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/BigInt/#value","title":"value","text":"<pre><code>@export var value: String\n</code></pre> <ul> <li>Setter: <code>@value_setter</code></li> <li>Getter: <code>@value_getter</code></li> </ul>"},{"location":"reference/BigInt/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/BigInt/#_init","title":"_init","text":"<pre><code>func _init(b: _BigInt = null) -&gt; BigInt\n</code></pre>"},{"location":"reference/BigInt/#add","title":"add","text":"<pre><code>func add(other: BigInt) -&gt; BigInt\n</code></pre> <p>Return the result of adding [param other].</p>"},{"location":"reference/BigInt/#mul","title":"mul","text":"<pre><code>func mul(other: BigInt) -&gt; BigInt\n</code></pre> <p>Return the result of multiplying by [param other].</p>"},{"location":"reference/BigInt/#eq","title":"eq","text":"<pre><code>func eq(other: BigInt) -&gt; bool\n</code></pre> <p>Check if is equal to [param other].</p>"},{"location":"reference/BigInt/#lt","title":"lt","text":"<pre><code>func lt(other: BigInt) -&gt; bool\n</code></pre> <p>Check if it is less than [param other].</p>"},{"location":"reference/BigInt/#gt","title":"gt","text":"<pre><code>func gt(other: BigInt) -&gt; bool\n</code></pre> <p>Check if it is greater than [param other].</p>"},{"location":"reference/BigInt/#negate","title":"negate","text":"<pre><code>func negate() -&gt; BigInt\n</code></pre> <p>Return the additive inverse.</p>"},{"location":"reference/BigInt/#sub","title":"sub","text":"<pre><code>func sub(other: BigInt) -&gt; BigInt\n</code></pre> <p>Return the result of substracting [param other].</p>"},{"location":"reference/BigInt/#to_str","title":"to_str","text":"<pre><code>func to_str() -&gt; String\n</code></pre> <p>Convert to [String].</p>"},{"location":"reference/BigInt/#to_int","title":"to_int","text":"<pre><code>func to_int() -&gt; int\n</code></pre>"},{"location":"reference/BigInt/#format_price","title":"format_price","text":"<pre><code>func format_price(quantity_decimals: float = 6, format_decimals: int = 2) -&gt; String\n</code></pre>"},{"location":"reference/BigInt/#from_str-static","title":"from_str (static)","text":"<pre><code>func from_str(s: String) -&gt; ConversionResult\n</code></pre> <p>Create a BigInt(BigInt).</p>"},{"location":"reference/BigInt/#from_int-static","title":"from_int (static)","text":"<pre><code>func from_int(n: int) -&gt; BigInt\n</code></pre> <p>Convert an [int] into a BigInt.</p>"},{"location":"reference/BigInt/#zero-static","title":"zero (static)","text":"<pre><code>func zero() -&gt; BigInt\n</code></pre> <p>Return 0</p>"},{"location":"reference/BigInt/#one-static","title":"one (static)","text":"<pre><code>func one() -&gt; BigInt\n</code></pre> <p>Return 1</p>"},{"location":"reference/BigInt/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/BigInt/#conversionresult","title":"ConversionResult","text":""},{"location":"reference/BigInt/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/BigInt/#value_1","title":"value","text":"<pre><code>var value: BigInt\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/BigInt/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/BoolData/","title":"BoolData","text":""},{"location":"reference/BoolData/#booldata","title":"BoolData","text":"<p>Extends: RefCounted</p>"},{"location":"reference/BoolData/#description","title":"Description","text":""},{"location":"reference/BoolData/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/BoolData/#_init","title":"_init","text":"<pre><code>func _init(b: bool) -&gt; BoolData\n</code></pre>"},{"location":"reference/BoolData/#to_data","title":"to_data","text":"<pre><code>func to_data() -&gt; PlutusData\n</code></pre>"},{"location":"reference/BoolData/#from_data-static","title":"from_data (static)","text":"<pre><code>func from_data(v: PlutusData) -&gt; BoolData\n</code></pre>"},{"location":"reference/Cbor/","title":"Cbor","text":""},{"location":"reference/Cbor/#cbor","title":"Cbor","text":"<p>Extends: RefCounted</p>"},{"location":"reference/Cbor/#description","title":"Description","text":""},{"location":"reference/Cbor/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/Cbor/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, DECODING_INVALID_INT = 1, DECODING_INVALID_BYTES = 2, DECODING_INVALID_CONSTR = 3, DECODING_INVALID_TAG = 4, DECODING_UNSUPPORTED_TYPE = 5, ENCODING_INVALID_TAG = 6, ENCODING_UNKNOWN_OBJECT = 7, ENCODING_UNSUPPORTED_TYPE = 8, CBOR_EVENT_ERROR = 9}\n</code></pre>"},{"location":"reference/Cbor/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Cbor/#deserialize-static","title":"deserialize (static)","text":"<pre><code>func deserialize(bytes: PackedByteArray) -&gt; DeserializeResult\n</code></pre>"},{"location":"reference/Cbor/#serialize-static","title":"serialize (static)","text":"<pre><code>func serialize(data: Variant) -&gt; SerializeResult\n</code></pre>"},{"location":"reference/Cbor/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/Cbor/#deserializeresult","title":"DeserializeResult","text":""},{"location":"reference/Cbor/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/Cbor/#value","title":"value","text":"<pre><code>var value: Variant\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/Cbor/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/Cbor/#serializeresult","title":"SerializeResult","text":""},{"location":"reference/Cbor/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/Cbor/#value_1","title":"value","text":"<pre><code>var value: PackedByteArray\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/Cbor/#error_1","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/Cip68Config/","title":"Cip68Config","text":""},{"location":"reference/Cip68Config/#cip68config","title":"Cip68Config","text":"<p>Extends: Resource</p>"},{"location":"reference/Cip68Config/#description","title":"Description","text":""},{"location":"reference/Cip68Config/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/Cip68Config/#minting_policy","title":"minting_policy","text":"<pre><code>@export var minting_policy: ScriptResource\n</code></pre>"},{"location":"reference/Cip68Config/#minting_policy_source","title":"minting_policy_source","text":"<pre><code>var minting_policy_source: PlutusScriptSource\n</code></pre>"},{"location":"reference/Cip68Config/#token_name","title":"token_name","text":"<pre><code>@export var token_name: PackedByteArray\n</code></pre> <ul> <li>Setter: <code>@token_name_setter</code></li> </ul> <p>The token name [b]body[/b] (i.e: the part of the token name that is not the CIP67 header).</p>"},{"location":"reference/Cip68Config/#token_name_as_hex","title":"token_name_as_hex","text":"<pre><code>@export var token_name_as_hex: String\n</code></pre> <ul> <li>Setter: <code>@token_name_as_hex_setter</code></li> <li>Getter: <code>@token_name_as_hex_getter</code></li> </ul> <p>The token name, hex-encoded.</p>"},{"location":"reference/Cip68Config/#token_name_as_utf8","title":"token_name_as_utf8","text":"<pre><code>@export var token_name_as_utf8: String\n</code></pre> <ul> <li>Setter: <code>@token_name_as_utf8_setter</code></li> <li>Getter: <code>@token_name_as_utf8_getter</code></li> </ul> <p>The token name, UTF-8 encoded.</p>"},{"location":"reference/Cip68Config/#name","title":"name","text":"<pre><code>@export var name: String\n</code></pre> <p>The standard \"name\" field.</p>"},{"location":"reference/Cip68Config/#image","title":"image","text":"<pre><code>@export var image: String\n</code></pre> <p>The standard \"image\" field. This should be a valid URI.</p>"},{"location":"reference/Cip68Config/#media_type","title":"media_type","text":"<pre><code>@export var media_type: String = \"image/webp\"\n</code></pre>"},{"location":"reference/Cip68Config/#description_1","title":"description","text":"<pre><code>@export var description: String = \"\"\n</code></pre> <p>The standard \"description\" field.</p>"},{"location":"reference/Cip68Config/#file_details","title":"file_details","text":"<pre><code>@export var file_details: Array[FileDetails]\n</code></pre> <p>An array of FileDetails.</p>"},{"location":"reference/Cip68Config/#non_standard_metadata","title":"non_standard_metadata","text":"<pre><code>@export var non_standard_metadata: Dictionary\n</code></pre> <ul> <li>Setter: <code>@non_standard_metadata_setter</code></li> </ul> <p>This is [i]non-standard[/i], [i]optional[/i] CIP-25 metadata.[br][br]Use this for any additional fields you want to provide that are not required by the CIP25 standard. Any field names overlapping with standard field names (like \"name\" and \"image\") will be ignored.  Keys of the dictionary should be [String]s, while values may be:[br][br]1. [String] (which will be converted [PackedByteArray])[br]2. [PackedByteArray][br]3. [int] (which will be converted to BigInt)[br]4. BigInt[br]5. [Array], [b]but only if its elements are valid values[/b].[br]6. [Dictionary], [b]but only if its keys and values are valid[/b].[br][br]Notably, you may not use neither [bool] nor [Constr]. If these conditions are too restrictive, take a look at [member Cip68ConfigPair.extra_plutus_data].</p>"},{"location":"reference/Cip68Config/#extra_plutus_data","title":"extra_plutus_data","text":"<pre><code>@export var extra_plutus_data: PlutusDataResource\n</code></pre>"},{"location":"reference/Cip68Config/#fungible","title":"fungible","text":"<pre><code>@export var fungible: bool = false\n</code></pre> <ul> <li>Setter: <code>@fungible_setter</code></li> </ul>"},{"location":"reference/Cip68Config/#initial_quantity","title":"initial_quantity","text":"<pre><code>@export var initial_quantity: int = 1\n</code></pre> <ul> <li>Setter: <code>@initial_quantity_setter</code></li> <li>Getter: <code>@initial_quantity_getter</code></li> </ul>"},{"location":"reference/Cip68Config/#big_int_script","title":"big_int_script","text":"<pre><code>var big_int_script: Script = \"&lt;GDScript#-9223370955277934683&gt;\"\n</code></pre>"},{"location":"reference/Cip68Config/#file_details_script","title":"file_details_script","text":"<pre><code>var file_details_script: Script = \"&lt;GDScript#-9223370955093385305&gt;\"\n</code></pre>"},{"location":"reference/Cip68Config/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Cip68Config/#get_user_token_name","title":"get_user_token_name","text":"<pre><code>func get_user_token_name() -&gt; AssetName\n</code></pre> <p>Get the CIP68 user token name</p>"},{"location":"reference/Cip68Config/#get_ref_token_name","title":"get_ref_token_name","text":"<pre><code>func get_ref_token_name() -&gt; AssetName\n</code></pre> <p>Get the CIP68 reference token name</p>"},{"location":"reference/Cip68Config/#get_quantity","title":"get_quantity","text":"<pre><code>func get_quantity() -&gt; BigInt\n</code></pre>"},{"location":"reference/Cip68Config/#to_data","title":"to_data","text":"<pre><code>func to_data() -&gt; Variant\n</code></pre> <p>The flag only applies for serializing the [member Cip68ConfigPair.extra_plutus_data]. The CIP25 metadata follows its own rules for serialization.</p>"},{"location":"reference/Cip68Config/#make_user_asset_class","title":"make_user_asset_class","text":"<pre><code>func make_user_asset_class(script_source: PlutusScriptSource = null) -&gt; AssetClass\n</code></pre>"},{"location":"reference/Cip68Config/#make_ref_asset_class","title":"make_ref_asset_class","text":"<pre><code>func make_ref_asset_class(script_source: PlutusScriptSource = null) -&gt; AssetClass\n</code></pre>"},{"location":"reference/Cip68Config/#init_script","title":"init_script","text":"<pre><code>func init_script(provider: Provider) -&gt; void\n</code></pre> <p>Load the minting policy from file or by querying the Provider. This must be performed in before most actions with this config will be possible.</p>"},{"location":"reference/Cip68Datum/","title":"Cip68Datum","text":""},{"location":"reference/Cip68Datum/#cip68datum","title":"Cip68Datum","text":"<p>Extends: Constr &lt; PlutusData &lt; Resource</p>"},{"location":"reference/Cip68Datum/#description","title":"Description","text":""},{"location":"reference/Cip68Datum/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Cip68Datum/#get_metadata","title":"get_metadata","text":"<pre><code>func get_metadata(key: String, default: PlutusData = null) -&gt; PlutusData\n</code></pre>"},{"location":"reference/Cip68Datum/#name","title":"name","text":"<pre><code>func name() -&gt; String\n</code></pre>"},{"location":"reference/Cip68Datum/#image_url","title":"image_url","text":"<pre><code>func image_url() -&gt; String\n</code></pre>"},{"location":"reference/Cip68Datum/#media_type","title":"media_type","text":"<pre><code>func media_type() -&gt; String\n</code></pre>"},{"location":"reference/Cip68Datum/#description_1","title":"description","text":"<pre><code>func description() -&gt; String\n</code></pre>"},{"location":"reference/Cip68Datum/#files","title":"files","text":"<pre><code>func files() -&gt; Array[FileDetails]\n</code></pre>"},{"location":"reference/Cip68Datum/#extra_plutus_data","title":"extra_plutus_data","text":"<pre><code>func extra_plutus_data() -&gt; PlutusData\n</code></pre>"},{"location":"reference/Cip68Datum/#copy_to_conf","title":"copy_to_conf","text":"<pre><code>func copy_to_conf(conf: Cip68Config) -&gt; void\n</code></pre>"},{"location":"reference/Cip68Datum/#unsafe_from_constr-static","title":"unsafe_from_constr (static)","text":"<pre><code>func unsafe_from_constr(data: Constr) -&gt; Cip68Datum\n</code></pre>"},{"location":"reference/Constr/","title":"Constr","text":""},{"location":"reference/Constr/#constr","title":"Constr","text":"<p>Extends: PlutusData &lt; Resource</p>"},{"location":"reference/Constr/#description","title":"Description","text":"<p>--- Introduction to algebraic types ---[br][br]Plutus supports the use of so called \"sum types\" and \"product types\". These are part of a more general concept called \"Algebraic Data Types\" (or ADTs for short).[br][br]Products are more common in programming languages, so we start with them. A product type is the \"combination\" of multiple types to create a larger one containing all of its constituents. These are normally known as \"tuples\", \"structs\" or even \"classes\" (but without any of the methods!).[br][br]In GDScript, the closest thing to product types are classes (though this might change soon with the inclusion of structs):[br][br] [codeblock] class StringAndInt:    var a_string: String    var an_int: int [/codeblock] [br][br]In the previous example, the class we defined was the product of type [String] and type [int]. The central characteristic of products is that [b]one can always decompose them into their constituents[/b], i.e: one can always get the [String] and [int] out of a \"StringAndInt\" class.[br][br]Sum types can also be described as a \"combination\" of other types. However, in contrast to products, [b]one can only extract a single component out of them[/b]. So the sum type that combines [String] and [int] would be called \"String[b]Or[/b]Int\". This SDK already uses sum types, like [Result], to encode different [b]exclusive[/b] possibilities [b]or choices[/b]. But sum types are not well supported by GDScript, so one must be careful not to try to extract the wrong component from a sum (since only one component can be extracted at any given time). In other languages, the language itself disallows access to the component without checking for its presence first (resulting in a static error).[br][br]--- How [Constr] works ---[br][br]Plutus supports both sums and products with a single type: [Constr]. A [Constr] (from constructor) is a \"sum of products\" (or SOP). As the name suggests, it is possibly many products combined in a sum.[br][br]The reason this works for representing pure sums and pure products is that:[br][br] A pure product can be thought of as a sum with [i]one choice[/i], where that choice is a product composed of possibly many types.[br] A pure sum can be thought of as a sum with [i]possibly many choices[/i], where all the choices are basic, non-product types.[br][br]And of course, any combination of sums and products that can be imagined is possible by nesting [Constr]s appropriately.[br][br]A [Constr] is built by providing an index (which represents the specific product selected) and an [Array] of fields (which represents the product itself). The index used for constructing a specific product is appropriately called \"constructor\".[br][br]--- Notes on ordering ---[br][br]It may be obvious that the constructor index represents an ordered choice, and hence using a different index will create a different value:[br][br][code] Constr.new(BigInt.zero(), x) /= Constr.new(BigInt.one(), x) [/code][br][br]But it is worth mentioning this is also the case when changing the order of the fields:[br][br][code] Constr.new(BigInt.zero(), [x, y]) /= Constr.new(BigInt.zero(), [y, x]) [/code][br][br]The order of the fields [b]does[/b] change the product, so this is something very important to keep in mind when trying to encode/decode values from the blockchain.</p> <p>--- Introduction to algebraic types ---[br][br]Plutus supports the use of so called \"sum types\" and \"product types\". These are part of a more general concept called \"Algebraic Data Types\" (or ADTs for short).[br][br]Products are more common in programming languages, so we start with them. A product type is the \"combination\" of multiple types to create a larger one containing all of its constituents. These are normally known as \"tuples\", \"structs\" or even \"classes\" (but without any of the methods!).[br][br]In GDScript, the closest thing to product types are classes (though this might change soon with the inclusion of structs):[br][br] [codeblock] class StringAndInt:    var a_string: String    var an_int: int [/codeblock] [br][br]In the previous example, the class we defined was the product of type [String] and type [int]. The central characteristic of products is that [b]one can always decompose them into their constituents[/b], i.e: one can always get the [String] and [int] out of a \"StringAndInt\" class.[br][br]Sum types can also be described as a \"combination\" of other types. However, in contrast to products, [b]one can only extract a single component out of them[/b]. So the sum type that combines [String] and [int] would be called \"String[b]Or[/b]Int\". This SDK already uses sum types, like [Result], to encode different [b]exclusive[/b] possibilities [b]or choices[/b]. But sum types are not well supported by GDScript, so one must be careful not to try to extract the wrong component from a sum (since only one component can be extracted at any given time). In other languages, the language itself disallows access to the component without checking for its presence first (resulting in a static error).[br][br]--- How [Constr] works ---[br][br]Plutus supports both sums and products with a single type: [Constr]. A [Constr] (from constructor) is a \"sum of products\" (or SOP). As the name suggests, it is possibly many products combined in a sum.[br][br]The reason this works for representing pure sums and pure products is that:[br][br] A pure product can be thought of as a sum with [i]one choice[/i], where that choice is a product composed of possibly many types.[br] A pure sum can be thought of as a sum with [i]possibly many choices[/i], where all the choices are basic, non-product types.[br][br]And of course, any combination of sums and products that can be imagined is possible by nesting [Constr]s appropriately.[br][br]A [Constr] is built by providing an index (which represents the specific product selected) and an [Array] of fields (which represents the product itself). The index used for constructing a specific product is appropriately called \"constructor\".[br][br]--- Notes on ordering ---[br][br]It may be obvious that the constructor index represents an ordered choice, and hence using a different index will create a different value:[br][br][code] Constr.new(BigInt.zero(), x) /= Constr.new(BigInt.one(), x) [/code][br][br]But it is worth mentioning this is also the case when changing the order of the fields:[br][br][code] Constr.new(BigInt.zero(), [x, y]) /= Constr.new(BigInt.zero(), [y, x]) [/code][br][br]The order of the fields [b]does[/b] change the product, so this is something very important to keep in mind when trying to encode/decode values from the blockchain.</p>"},{"location":"reference/Constr/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Constr/#_init","title":"_init","text":"<pre><code>func _init(constructor: BigInt = null, fields: Array[PlutusData] = null) -&gt; Constr\n</code></pre> <p>A Constr.</p>"},{"location":"reference/Constr/#get_constructor","title":"get_constructor","text":"<pre><code>func get_constructor() -&gt; BigInt\n</code></pre> <p>Get the constructor index.</p>"},{"location":"reference/Constr/#get_fields","title":"get_fields","text":"<pre><code>func get_fields() -&gt; Array[PlutusData]\n</code></pre> <p>Get the fields of the product.</p>"},{"location":"reference/CostModels/","title":"CostModels","text":""},{"location":"reference/CostModels/#costmodels","title":"CostModels","text":"<p>Extends: RefCounted</p>"},{"location":"reference/CostModels/#description","title":"Description","text":"<p>This class is used to represent the cost models of the different Plutus versions supported by the SDK.</p> <p>This class is used to represent the cost models of the different Plutus versions supported by the SDK.</p>"},{"location":"reference/CostModels/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/CostModels/#_init","title":"_init","text":"<pre><code>func _init(cost_models: Dictionary) -&gt; CostModels\n</code></pre>"},{"location":"reference/Credential/","title":"Credential","text":""},{"location":"reference/Credential/#credential","title":"Credential","text":"<p>Extends: RefCounted</p>"},{"location":"reference/Credential/#description","title":"Description","text":""},{"location":"reference/Credential/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/Credential/#credentialtype","title":"CredentialType","text":"<pre><code>enum CredentialType{PAYMENT = 0, STAKE = 1}\n</code></pre>"},{"location":"reference/Credential/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, INCORRECT_TYPE = 1}\n</code></pre>"},{"location":"reference/Credential/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Credential/#_init","title":"_init","text":"<pre><code>func _init(credential: _Credential) -&gt; Credential\n</code></pre>"},{"location":"reference/Credential/#get_type","title":"get_type","text":"<pre><code>func get_type() -&gt; Credential.CredentialType\n</code></pre>"},{"location":"reference/Credential/#to_bytes","title":"to_bytes","text":"<pre><code>func to_bytes() -&gt; PackedByteArray\n</code></pre>"},{"location":"reference/Credential/#to_hex","title":"to_hex","text":"<pre><code>func to_hex() -&gt; String\n</code></pre>"},{"location":"reference/Credential/#to_pub_key_hash","title":"to_pub_key_hash","text":"<pre><code>func to_pub_key_hash() -&gt; ToPubKeyHashResult\n</code></pre>"},{"location":"reference/Credential/#to_script_hash","title":"to_script_hash","text":"<pre><code>func to_script_hash() -&gt; ToScriptHashResult\n</code></pre>"},{"location":"reference/Credential/#from_script-static","title":"from_script (static)","text":"<pre><code>func from_script(script: PlutusScript) -&gt; Credential\n</code></pre>"},{"location":"reference/Credential/#from_script_hash-static","title":"from_script_hash (static)","text":"<pre><code>func from_script_hash(script_hash: ScriptHash) -&gt; Credential\n</code></pre>"},{"location":"reference/Credential/#from_script_source-static","title":"from_script_source (static)","text":"<pre><code>func from_script_source(script_source: PlutusScriptSource) -&gt; Credential\n</code></pre>"},{"location":"reference/Credential/#from_key_hash-static","title":"from_key_hash (static)","text":"<pre><code>func from_key_hash(key_hash: PubKeyHash) -&gt; Credential\n</code></pre>"},{"location":"reference/Credential/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/Credential/#topubkeyhashresult","title":"ToPubKeyHashResult","text":""},{"location":"reference/Credential/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/Credential/#value","title":"value","text":"<pre><code>var value: PubKeyHash\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/Credential/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/Credential/#toscripthashresult","title":"ToScriptHashResult","text":""},{"location":"reference/Credential/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/Credential/#value_1","title":"value","text":"<pre><code>var value: ScriptHash\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/Credential/#error_1","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/FileDetails/","title":"FileDetails","text":""},{"location":"reference/FileDetails/#filedetails","title":"FileDetails","text":"<p>Extends: Resource</p>"},{"location":"reference/FileDetails/#description","title":"Description","text":"<p>The CIP25 standard (and hence the CIP68 standard as well) defines an optional \"file details\" field that can be used to attach additional files to a token.</p> <p>The CIP25 standard (and hence the CIP68 standard as well) defines an optional \"file details\" field that can be used to attach additional files to a token.</p>"},{"location":"reference/FileDetails/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/FileDetails/#name","title":"name","text":"<pre><code>@export var name: String = \"\"\n</code></pre>"},{"location":"reference/FileDetails/#media_type","title":"media_type","text":"<pre><code>@export var media_type: String\n</code></pre>"},{"location":"reference/FileDetails/#src","title":"src","text":"<pre><code>@export var src: String\n</code></pre>"},{"location":"reference/FileDetails/#additional_properties","title":"additional_properties","text":"<pre><code>@export var additional_properties: Dictionary\n</code></pre>"},{"location":"reference/FileDetails/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/FileDetails/#as_dict","title":"as_dict","text":"<pre><code>func as_dict()\n</code></pre>"},{"location":"reference/FileDetails/#from_dict-static","title":"from_dict (static)","text":"<pre><code>func from_dict(dict: Dictionary) -&gt; FileDetails\n</code></pre>"},{"location":"reference/MultiAsset/","title":"MultiAsset","text":""},{"location":"reference/MultiAsset/#multiasset","title":"MultiAsset","text":"<p>Extends: RefCounted</p>"},{"location":"reference/MultiAsset/#description","title":"Description","text":"<p>A value held at a Utxo is used for representing these assets and their respective quantities.</p> <p>A value held at a Utxo is used for representing these assets and their respective quantities.</p>"},{"location":"reference/MultiAsset/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/MultiAsset/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, COULD_NOT_EXTRACT_POLICY_ID = 1, COULD_NOT_EXTRACT_ASSET_NAME = 2, COULD_NOT_DECODE_HEX = 3, INVALID_ASSET_NAME = 4, OTHER_ERROR = 5}\n</code></pre>"},{"location":"reference/MultiAsset/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/MultiAsset/#_init","title":"_init","text":"<pre><code>func _init(multi_asset: _MultiAsset) -&gt; MultiAsset\n</code></pre>"},{"location":"reference/MultiAsset/#get_asset_quantity","title":"get_asset_quantity","text":"<pre><code>func get_asset_quantity(asset: AssetClass) -&gt; BigInt\n</code></pre> <p>Return the quantity of the given [param asset] held.</p>"},{"location":"reference/MultiAsset/#set_asset_quantity","title":"set_asset_quantity","text":"<pre><code>func set_asset_quantity(asset: AssetClass, quantity: BigInt) -&gt; SetAssetResult\n</code></pre> <p>Set the [param quantity] of the given [param asset].</p>"},{"location":"reference/MultiAsset/#add_asset","title":"add_asset","text":"<pre><code>func add_asset(asset: AssetClass, quantity: BigInt) -&gt; SetAssetResult\n</code></pre>"},{"location":"reference/MultiAsset/#merge","title":"merge","text":"<pre><code>func merge(other: MultiAsset)\n</code></pre>"},{"location":"reference/MultiAsset/#to_dictionary","title":"to_dictionary","text":"<pre><code>func to_dictionary() -&gt; Dictionary\n</code></pre> <p>Convert to a dictionary representation. This can be used by [method from_dictionary].</p>"},{"location":"reference/MultiAsset/#duplicate","title":"duplicate","text":"<pre><code>func duplicate() -&gt; MultiAsset\n</code></pre>"},{"location":"reference/MultiAsset/#from_dictionary-static","title":"from_dictionary (static)","text":"<pre><code>func from_dictionary(assets: Dictionary) -&gt; FromDictionaryResult\n</code></pre> <p>Try to parse a dictionary into a MultiAssets as values.</p>"},{"location":"reference/MultiAsset/#empty-static","title":"empty (static)","text":"<pre><code>func empty() -&gt; MultiAsset\n</code></pre> <p>Return a value with no assets</p>"},{"location":"reference/MultiAsset/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/MultiAsset/#fromdictionaryresult","title":"FromDictionaryResult","text":""},{"location":"reference/MultiAsset/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/MultiAsset/#value","title":"value","text":"<pre><code>var value: MultiAsset\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/MultiAsset/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/MultiAsset/#setassetresult","title":"SetAssetResult","text":""},{"location":"reference/MultiAsset/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/MultiAsset/#value_1","title":"value","text":"<pre><code>var value: Variant\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/MultiAsset/#error_1","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/OnlineWallet/","title":"OnlineWallet","text":""},{"location":"reference/OnlineWallet/#onlinewallet","title":"OnlineWallet","text":"<p>Extends: Node</p>"},{"location":"reference/OnlineWallet/#description","title":"Description","text":"<p>This class is used for providing wallet-related online functionality, such as querying for the assets or UTxOs locked at the wallet. These features are possible due to the required [Provider] in its constructor.</p> <p>This class is used for providing wallet-related online functionality, such as querying for the assets or UTxOs locked at the wallet. These features are possible due to the required [Provider] in its constructor.</p>"},{"location":"reference/OnlineWallet/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/OnlineWallet/#active","title":"active","text":"<pre><code>var active: bool = false\n</code></pre>"},{"location":"reference/OnlineWallet/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/OnlineWallet/#total_lovelace","title":"total_lovelace","text":"<pre><code>func total_lovelace() -&gt; BigInt\n</code></pre> <p>Get the amount of Lovelace locked among all of the wallet's UTxOs</p>"},{"location":"reference/OnlineWallet/#new_tx","title":"new_tx","text":"<pre><code>func new_tx() -&gt; CreateResult\n</code></pre> <p>Create a TxBuilder.</p>"},{"location":"reference/OnlineWallet/#sign_transaction","title":"sign_transaction","text":"<pre><code>func sign_transaction(password: String, transaction: Transaction) -&gt; SignTxResult\n</code></pre>"},{"location":"reference/OnlineWallet/#get_address","title":"get_address","text":"<pre><code>func get_address() -&gt; Address\n</code></pre>"},{"location":"reference/OnlineWallet/#get_utxos","title":"get_utxos","text":"<pre><code>func get_utxos() -&gt; Array[Utxo]\n</code></pre>"},{"location":"reference/OnlineWallet/#get_payment_pub_key_hash","title":"get_payment_pub_key_hash","text":"<pre><code>func get_payment_pub_key_hash() -&gt; PubKeyHash\n</code></pre>"},{"location":"reference/OnlineWallet/#signals","title":"Signals","text":"<ul> <li>signal got_updated_utxos(utxos): </li> </ul>"},{"location":"reference/OnlineWallet/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/OnlineWallet/#signtxresult","title":"SignTxResult","text":""},{"location":"reference/OnlineWallet/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/OnlineWallet/#value","title":"value","text":"<pre><code>var value: Signature\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/OnlineWallet/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/OnlineWallet/#onlinesingleaddresswallet","title":"OnlineSingleAddressWallet","text":""},{"location":"reference/OnlineWallet/#property-descriptions_2","title":"Property Descriptions","text":""},{"location":"reference/OnlineWallet/#utxos_update_age","title":"utxos_update_age","text":"<pre><code>@export var utxos_update_age: float = 30\n</code></pre>"},{"location":"reference/OnlineWallet/#utxos_cache_age","title":"utxos_cache_age","text":"<pre><code>@export var utxos_cache_age: float = 30\n</code></pre>"},{"location":"reference/OnlineWallet/#time_left","title":"time_left","text":"<pre><code>var time_left: float\n</code></pre> <ul> <li>Getter: <code>@time_left_getter</code></li> </ul>"},{"location":"reference/OnlineWallet/#timer","title":"timer","text":"<pre><code>var timer: Timer\n</code></pre>"},{"location":"reference/OnlineWallet/#utxos","title":"utxos","text":"<pre><code>var utxos: Array[Utxo]\n</code></pre> <p>Cached utxos, these can and will be outdated. To get the latest utxos, call OnlineWallet._get_utxos.</p>"},{"location":"reference/OnlineWallet/#method-descriptions_1","title":"Method Descriptions","text":""},{"location":"reference/OnlineWallet/#_init","title":"_init","text":"<pre><code>func _init(single_address_wallet: SingleAddressWallet, provider: Provider, auto_update_utxos: bool = true) -&gt; OnlineSingleAddressWallet\n</code></pre> <p>Construct the wallet by providing a SingleAddressWallet(SingleAddressWallet) (for the network functionality).</p>"},{"location":"reference/OnlineWallet/#update_utxos","title":"update_utxos","text":"<pre><code>func update_utxos() -&gt; void\n</code></pre> <p>Update the cached utxos. The same as OnlineWallet._get_utxos, but without returning the updated utxos.</p>"},{"location":"reference/OnlineWallet/#add_account","title":"add_account","text":"<pre><code>func add_account(account_index: int, password: String) -&gt; AddAccountResult\n</code></pre> <p>Add a new account to the wallet.</p>"},{"location":"reference/OnlineWallet/#switch_account","title":"switch_account","text":"<pre><code>func switch_account(account: Account) -&gt; int\n</code></pre> <p>Switch the active account in the wallet.</p>"},{"location":"reference/OnlineWallet/#send_lovelace_to","title":"send_lovelace_to","text":"<pre><code>func send_lovelace_to(password: String, recipient: String, amount: BigInt) -&gt; TransactionHash\n</code></pre> <p>Send a lovelace amount to a [param recipient] BECH32 address. This is provided for convenience, as it avoids using the [TxBuilder] interface.</p>"},{"location":"reference/OnlineWallet/#tx_with","title":"tx_with","text":"<pre><code>func tx_with(builder: Callable, signer: Callable) -&gt; TransactionHash\n</code></pre> <p>See [method Provider.tx_with]</p>"},{"location":"reference/PlutusBytes/","title":"PlutusBytes","text":""},{"location":"reference/PlutusBytes/#plutusbytes","title":"PlutusBytes","text":"<p>Extends: PlutusData &lt; Resource</p>"},{"location":"reference/PlutusBytes/#description","title":"Description","text":""},{"location":"reference/PlutusBytes/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/PlutusBytes/#_init","title":"_init","text":"<pre><code>func _init(data: PackedByteArray = null) -&gt; PlutusBytes\n</code></pre>"},{"location":"reference/PlutusBytes/#get_data","title":"get_data","text":"<pre><code>func get_data() -&gt; PackedByteArray\n</code></pre>"},{"location":"reference/PlutusBytes/#from_utf8-static","title":"from_utf8 (static)","text":"<pre><code>func from_utf8(s: String) -&gt; PlutusBytes\n</code></pre>"},{"location":"reference/PlutusBytes/#from_hex-static","title":"from_hex (static)","text":"<pre><code>func from_hex(s: String) -&gt; PlutusBytes\n</code></pre>"},{"location":"reference/PlutusData/","title":"PlutusData","text":""},{"location":"reference/PlutusData/#plutusdata","title":"PlutusData","text":"<p>Extends: Resource</p>"},{"location":"reference/PlutusData/#description","title":"Description","text":"<p>The Plutus language, which may be used for minting policies and validators, operates on a specific datatype called PlutusData.</p> <p>The Plutus language, which may be used for minting policies and validators, operates on a specific datatype called PlutusData.</p>"},{"location":"reference/PlutusData/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/PlutusData/#to_json","title":"to_json","text":"<pre><code>func to_json() -&gt; Dictionary\n</code></pre>"},{"location":"reference/PlutusData/#equals","title":"equals","text":"<pre><code>func equals(other: PlutusData) -&gt; bool\n</code></pre>"},{"location":"reference/PlutusData/#serialize","title":"serialize","text":"<pre><code>func serialize() -&gt; SerializeResult\n</code></pre> <p>Serialize into CBOR format.</p>"},{"location":"reference/PlutusData/#wrap-static","title":"wrap (static)","text":"<pre><code>func wrap(v: Variant) -&gt; PlutusData\n</code></pre> <p>Recursively unwraps Objects to Plutus compatible data types</p>"},{"location":"reference/PlutusData/#deserialize-static","title":"deserialize (static)","text":"<pre><code>func deserialize(bytes: PackedByteArray) -&gt; PlutusData\n</code></pre> <p>Deserialize from CBOR format.</p>"},{"location":"reference/PlutusData/#from_json-static","title":"from_json (static)","text":"<pre><code>func from_json(json: Dictionary) -&gt; PlutusData\n</code></pre> <p>Converts parsed JSON to PlutusData</p>"},{"location":"reference/PlutusData/#apply_script_parameters-static","title":"apply_script_parameters (static)","text":"<pre><code>func apply_script_parameters(script: PlutusScript, params: Array[PlutusData]) -&gt; PlutusScript\n</code></pre> <p>Apply the given [param params] to the passed [param script]. This only makes sense in unapplied, parameterized scripts.</p>"},{"location":"reference/PlutusDataResource/","title":"PlutusDataResource","text":""},{"location":"reference/PlutusDataResource/#plutusdataresource","title":"PlutusDataResource","text":"<p>Extends: Resource</p>"},{"location":"reference/PlutusDataResource/#description","title":"Description","text":""},{"location":"reference/PlutusDataResource/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/PlutusDataResource/#datatype","title":"DataType","text":"<pre><code>enum DataType{INT = 0, BYTES = 1, JSON_FILE = 2, JSON_INLINE = 3, CBOR_HEX = 4}\n</code></pre>"},{"location":"reference/PlutusDataResource/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/PlutusDataResource/#data","title":"data","text":"<pre><code>var data: PlutusData\n</code></pre> <ul> <li>Setter: <code>@data_setter</code></li> <li>Getter: <code>@data_getter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_type","title":"data_type","text":"<pre><code>@export var data_type: PlutusDataResource.DataType = 0\n</code></pre> <ul> <li>Setter: <code>@data_type_setter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_int","title":"data_int","text":"<pre><code>@export var data_int: int\n</code></pre> <ul> <li>Setter: <code>@data_int_setter</code></li> <li>Getter: <code>@data_int_getter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_bytes","title":"data_bytes","text":"<pre><code>@export var data_bytes: PackedByteArray\n</code></pre> <ul> <li>Setter: <code>@data_bytes_setter</code></li> <li>Getter: <code>@data_bytes_getter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_as_hex","title":"data_as_hex","text":"<pre><code>@export var data_as_hex: String\n</code></pre> <ul> <li>Setter: <code>@data_as_hex_setter</code></li> <li>Getter: <code>@data_as_hex_getter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_as_utf8","title":"data_as_utf8","text":"<pre><code>@export var data_as_utf8: String\n</code></pre> <ul> <li>Setter: <code>@data_as_utf8_setter</code></li> <li>Getter: <code>@data_as_utf8_getter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_cbor","title":"data_cbor","text":"<pre><code>var data_cbor: PackedByteArray\n</code></pre> <ul> <li>Setter: <code>@data_cbor_setter</code></li> <li>Getter: <code>@data_cbor_getter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_cbor_hex","title":"data_cbor_hex","text":"<pre><code>@export var data_cbor_hex: String\n</code></pre> <ul> <li>Setter: <code>@data_cbor_hex_setter</code></li> <li>Getter: <code>@data_cbor_hex_getter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_json","title":"data_json","text":"<pre><code>@export var data_json: String\n</code></pre> <ul> <li>Setter: <code>@data_json_setter</code></li> <li>Getter: <code>@data_json_getter</code></li> </ul>"},{"location":"reference/PlutusDataResource/#data_json_path","title":"data_json_path","text":"<pre><code>@export var data_json_path: String = \"\"\n</code></pre>"},{"location":"reference/PlutusList/","title":"PlutusList","text":""},{"location":"reference/PlutusList/#plutuslist","title":"PlutusList","text":"<p>Extends: PlutusData &lt; Resource</p>"},{"location":"reference/PlutusList/#description","title":"Description","text":""},{"location":"reference/PlutusList/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/PlutusList/#_init","title":"_init","text":"<pre><code>func _init(data: Array[PlutusData] = null) -&gt; PlutusList\n</code></pre>"},{"location":"reference/PlutusList/#get_data","title":"get_data","text":"<pre><code>func get_data() -&gt; Array[PlutusData]\n</code></pre>"},{"location":"reference/PlutusMap/","title":"PlutusMap","text":""},{"location":"reference/PlutusMap/#plutusmap","title":"PlutusMap","text":"<p>Extends: PlutusData &lt; Resource</p>"},{"location":"reference/PlutusMap/#description","title":"Description","text":""},{"location":"reference/PlutusMap/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/PlutusMap/#_init","title":"_init","text":"<pre><code>func _init(data: Dictionary = null) -&gt; PlutusMap\n</code></pre>"},{"location":"reference/PlutusMap/#get_data","title":"get_data","text":"<pre><code>func get_data() -&gt; Dictionary\n</code></pre>"},{"location":"reference/PlutusPair/","title":"PlutusPair","text":""},{"location":"reference/PlutusPair/#plutuspair","title":"PlutusPair","text":"<p>Extends: PlutusData &lt; Resource</p>"},{"location":"reference/PlutusPair/#description","title":"Description","text":""},{"location":"reference/PlutusPair/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/PlutusPair/#_init","title":"_init","text":"<pre><code>func _init(first: PlutusData = null, second: PlutusData = null) -&gt; PlutusPair\n</code></pre>"},{"location":"reference/PolicyId/","title":"PolicyId","text":""},{"location":"reference/PolicyId/#policyid","title":"PolicyId","text":"<p>Extends: RefCounted</p>"},{"location":"reference/PolicyId/#description","title":"Description","text":""},{"location":"reference/PolicyId/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/PolicyId/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, COULD_NOT_DECODE_HEX = 1}\n</code></pre>"},{"location":"reference/PolicyId/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/PolicyId/#_init","title":"_init","text":"<pre><code>func _init(policy_id: _PolicyId) -&gt; PolicyId\n</code></pre> <p>WARNING: Do not use this constructor directly, use [method from_hex], [method from_script] or [method from_script_source] for safe building.</p>"},{"location":"reference/PolicyId/#to_hex","title":"to_hex","text":"<pre><code>func to_hex() -&gt; String\n</code></pre> <p>Get the hex encoding of the minting policy's hash</p>"},{"location":"reference/PolicyId/#from_hex-static","title":"from_hex (static)","text":"<pre><code>func from_hex(hash: String) -&gt; FromHexResult\n</code></pre> <p>Try to parse a PolicyId encoded as hex.</p>"},{"location":"reference/PolicyId/#from_script-static","title":"from_script (static)","text":"<pre><code>func from_script(script: PlutusScript) -&gt; PolicyId\n</code></pre> <p>Obtain a PolicyId.</p>"},{"location":"reference/PolicyId/#from_script_source-static","title":"from_script_source (static)","text":"<pre><code>func from_script_source(script_source: PlutusScriptSource) -&gt; PolicyId\n</code></pre> <p>Obtain a PolicyId.</p>"},{"location":"reference/PolicyId/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/PolicyId/#fromhexresult","title":"FromHexResult","text":""},{"location":"reference/PolicyId/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/PolicyId/#value","title":"value","text":"<pre><code>var value: PolicyId\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/PolicyId/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/PubKeyHash/","title":"PubKeyHash","text":""},{"location":"reference/PubKeyHash/#pubkeyhash","title":"PubKeyHash","text":"<p>Extends: RefCounted</p>"},{"location":"reference/PubKeyHash/#description","title":"Description","text":""},{"location":"reference/PubKeyHash/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/PubKeyHash/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, FROM_HEX_ERROR = 1}\n</code></pre>"},{"location":"reference/PubKeyHash/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/PubKeyHash/#_init","title":"_init","text":"<pre><code>func _init(pub_key_hash: _PubKeyHash) -&gt; PubKeyHash\n</code></pre> <p>WARNING: Do not use this constructor directly, instead use [method from_hex] for a safe way of building a [PubKeyHash].</p>"},{"location":"reference/PubKeyHash/#to_hex","title":"to_hex","text":"<pre><code>func to_hex() -&gt; String\n</code></pre> <p>Return a [String] containing the hex-encoded hash.</p>"},{"location":"reference/PubKeyHash/#to_bytes","title":"to_bytes","text":"<pre><code>func to_bytes() -&gt; PackedByteArray\n</code></pre>"},{"location":"reference/PubKeyHash/#from_hex-static","title":"from_hex (static)","text":"<pre><code>func from_hex(hash: String) -&gt; FromHexResult\n</code></pre> <p>Tries to parse a [PubKeyhash] from the [param hash] passed as a hex-encoded [String].</p>"},{"location":"reference/PubKeyHash/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/PubKeyHash/#fromhexresult","title":"FromHexResult","text":""},{"location":"reference/PubKeyHash/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/PubKeyHash/#value","title":"value","text":"<pre><code>var value: PubKeyHash\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/PubKeyHash/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/Result/","title":"Result","text":""},{"location":"reference/Result/#result","title":"Result","text":"<p>Extends: RefCounted</p>"},{"location":"reference/Result/#description","title":"Description","text":"<p>A virtual class that represents an arbitrary result from executing an operation. This class should never be used directly, it's only meant to be inherited from.  The Result. All classes that expose operations which may fail, will also expose a \"Status\" enum that can be used to distinguish the different failure modes.</p> <p>A virtual class that represents an arbitrary result from executing an operation. This class should never be used directly, it's only meant to be inherited from.  The Result. All classes that expose operations which may fail, will also expose a \"Status\" enum that can be used to distinguish the different failure modes.</p>"},{"location":"reference/Result/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Result/#_init","title":"_init","text":"<pre><code>func _init(res: _Result) -&gt; Result\n</code></pre>"},{"location":"reference/Result/#is_ok","title":"is_ok","text":"<pre><code>func is_ok() -&gt; bool\n</code></pre> <p>Returns true if the operation succeeded</p>"},{"location":"reference/Result/#is_err","title":"is_err","text":"<pre><code>func is_err() -&gt; bool\n</code></pre> <p>Returns true if the operation failed</p>"},{"location":"reference/Result/#tag","title":"tag","text":"<pre><code>func tag() -&gt; int\n</code></pre> <p>Returns a tag representing the status of the operation. This can be used in pattern matching.   Consult the [Status] enum of the class.</p>"},{"location":"reference/Result/#sequence-static","title":"sequence (static)","text":"<pre><code>func sequence(results: Array[Result]) -&gt; ArrayResult\n</code></pre> <p>Convert an [Array] of [Result]s into a [Result] containing either an [Array] with [b]all[/b] of the values or the first error found in the [Array].</p>"},{"location":"reference/Result/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/Result/#ok","title":"Ok","text":""},{"location":"reference/Result/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/Result/#value","title":"value","text":"<pre><code>var value: Variant\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul>"},{"location":"reference/Result/#method-descriptions_1","title":"Method Descriptions","text":""},{"location":"reference/Result/#_init_1","title":"_init","text":"<pre><code>func _init(value: Variant) -&gt; Ok\n</code></pre>"},{"location":"reference/Result/#err","title":"Err","text":""},{"location":"reference/Result/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/Result/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul>"},{"location":"reference/Result/#method-descriptions_2","title":"Method Descriptions","text":""},{"location":"reference/Result/#_init_2","title":"_init","text":"<pre><code>func _init(err: String, tag: int) -&gt; Err\n</code></pre>"},{"location":"reference/Result/#variantresult","title":"VariantResult","text":""},{"location":"reference/Result/#property-descriptions_2","title":"Property Descriptions","text":""},{"location":"reference/Result/#value_1","title":"value","text":"<pre><code>var value: Variant\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/Result/#error_1","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/Result/#arrayresult","title":"ArrayResult","text":""},{"location":"reference/Result/#property-descriptions_3","title":"Property Descriptions","text":""},{"location":"reference/Result/#value_2","title":"value","text":"<pre><code>var value: Array\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/Result/#error_2","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/ScriptFromBlueprint/","title":"ScriptFromBlueprint","text":""},{"location":"reference/ScriptFromBlueprint/#scriptfromblueprint","title":"ScriptFromBlueprint","text":"<p>Extends: ScriptFromCborHex &lt; ScriptResource &lt; Resource</p>"},{"location":"reference/ScriptFromBlueprint/#description","title":"Description","text":""},{"location":"reference/ScriptFromBlueprint/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/ScriptFromBlueprint/#blueprint_path","title":"blueprint_path","text":"<pre><code>@export var blueprint_path: String\n</code></pre>"},{"location":"reference/ScriptFromBlueprint/#validator_name","title":"validator_name","text":"<pre><code>@export var validator_name: String\n</code></pre>"},{"location":"reference/ScriptFromCborHex/","title":"ScriptFromCborHex","text":""},{"location":"reference/ScriptFromCborHex/#scriptfromcborhex","title":"ScriptFromCborHex","text":"<p>Extends: ScriptResource &lt; Resource</p>"},{"location":"reference/ScriptFromCborHex/#description","title":"Description","text":""},{"location":"reference/ScriptFromCborHex/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/ScriptFromCborHex/#cbor_hex","title":"cbor_hex","text":"<pre><code>@export var cbor_hex: String = \"\"\n</code></pre>"},{"location":"reference/ScriptFromCborHex/#plutus_version","title":"plutus_version","text":"<pre><code>@export var plutus_version: int = 2\n</code></pre>"},{"location":"reference/ScriptFromCborHex/#script_args","title":"script_args","text":"<pre><code>@export var script_args: Array[PlutusDataResource]\n</code></pre>"},{"location":"reference/ScriptFromOutRef/","title":"ScriptFromOutRef","text":""},{"location":"reference/ScriptFromOutRef/#scriptfromoutref","title":"ScriptFromOutRef","text":"<p>Extends: ScriptResource &lt; Resource</p>"},{"location":"reference/ScriptFromOutRef/#description","title":"Description","text":""},{"location":"reference/ScriptFromOutRef/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/ScriptFromOutRef/#tx_hash","title":"tx_hash","text":"<pre><code>@export var tx_hash: String\n</code></pre>"},{"location":"reference/ScriptFromOutRef/#output_index","title":"output_index","text":"<pre><code>@export var output_index: int\n</code></pre>"},{"location":"reference/ScriptFromOutRef/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/ScriptFromOutRef/#_init","title":"_init","text":"<pre><code>func _init(tx_hash: TransactionHash = null, output_index: int = 0) -&gt; ScriptFromOutRef\n</code></pre>"},{"location":"reference/ScriptHash/","title":"ScriptHash","text":""},{"location":"reference/ScriptHash/#scripthash","title":"ScriptHash","text":"<p>Extends: RefCounted</p>"},{"location":"reference/ScriptHash/#description","title":"Description","text":""},{"location":"reference/ScriptHash/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/ScriptHash/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, FROM_HEX_ERROR = 1}\n</code></pre>"},{"location":"reference/ScriptHash/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/ScriptHash/#_init","title":"_init","text":"<pre><code>func _init(script_hash: _ScriptHash) -&gt; ScriptHash\n</code></pre>"},{"location":"reference/ScriptHash/#to_hex","title":"to_hex","text":"<pre><code>func to_hex() -&gt; String\n</code></pre>"},{"location":"reference/ScriptHash/#to_bytes","title":"to_bytes","text":"<pre><code>func to_bytes() -&gt; PackedByteArray\n</code></pre>"},{"location":"reference/ScriptHash/#from_hex-static","title":"from_hex (static)","text":"<pre><code>func from_hex(hash: String) -&gt; FromHexResult\n</code></pre>"},{"location":"reference/ScriptHash/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/ScriptHash/#fromhexresult","title":"FromHexResult","text":""},{"location":"reference/ScriptHash/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/ScriptHash/#value","title":"value","text":"<pre><code>var value: ScriptHash\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/ScriptHash/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/ScriptResource/","title":"ScriptResource","text":""},{"location":"reference/ScriptResource/#scriptresource","title":"ScriptResource","text":"<p>Extends: Resource</p>"},{"location":"reference/ScriptResource/#description","title":"Description","text":""},{"location":"reference/ScriptResource/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/ScriptResource/#load_script","title":"load_script","text":"<pre><code>func load_script(provider: Provider = null) -&gt; PlutusScriptSource\n</code></pre>"},{"location":"reference/SingleAddressWallet/","title":"SingleAddressWallet","text":""},{"location":"reference/SingleAddressWallet/#singleaddresswallet","title":"SingleAddressWallet","text":"<p>Extends: RefCounted</p>"},{"location":"reference/SingleAddressWallet/#description","title":"Description","text":"<p>This class holds the [b]encrypted[/b] master private key of a user's wallet. It can be used for offline wallet operations and queries, such as signing, adding accounts and consulting addresses.  You should create a SingleAddressWallet with [SingleAddressWalletLoader], by calling any of its creation or import methods.  Refer to [OnlineWallet] for a class that has network connectivity and can do blockchain queries. In general, this class is the one you are interested in for dApp development.</p> <p>This class holds the [b]encrypted[/b] master private key of a user's wallet. It can be used for offline wallet operations and queries, such as signing, adding accounts and consulting addresses.  You should create a SingleAddressWallet with [SingleAddressWalletLoader], by calling any of its creation or import methods.  Refer to [OnlineWallet] for a class that has network connectivity and can do blockchain queries. In general, this class is the one you are interested in for dApp development.</p>"},{"location":"reference/SingleAddressWallet/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/SingleAddressWallet/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, DECRYPTION_ERROR = 1, BAD_DECRYPTED_KEY = 2, BECH32_ERROR = 3, NON_EXISTENT_ACCOUNT = 4}\n</code></pre>"},{"location":"reference/SingleAddressWallet/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/SingleAddressWallet/#_init","title":"_init","text":"<pre><code>func _init(wallet: _SingleAddressWallet, wallet_loader: SingleAddressWalletLoader) -&gt; SingleAddressWallet\n</code></pre> <p>WARNING: Do not use this constructor! Use any of the import/creation methods exposed in [SingleAddressWalletLoader].</p>"},{"location":"reference/SingleAddressWallet/#get_address","title":"get_address","text":"<pre><code>func get_address() -&gt; Address\n</code></pre> <p>Get the account's Address</p>"},{"location":"reference/SingleAddressWallet/#get_address_bech32","title":"get_address_bech32","text":"<pre><code>func get_address_bech32() -&gt; String\n</code></pre> <p>Get the account's address as a BECH32-encoded [String].</p>"},{"location":"reference/SingleAddressWallet/#get_address_hex","title":"get_address_hex","text":"<pre><code>func get_address_hex() -&gt; String\n</code></pre>"},{"location":"reference/SingleAddressWallet/#sign_transaction","title":"sign_transaction","text":"<pre><code>func sign_transaction(password: String, tx: Transaction) -&gt; SignTxResult\n</code></pre> <p>Sign the given Transaction</p>"},{"location":"reference/SingleAddressWallet/#sign_data","title":"sign_data","text":"<pre><code>func sign_data(password: String, data: String) -&gt; SignDataResult\n</code></pre> <p>Sign the given [String] representing hex encoded payload and obtain a [DataSignature]</p>"},{"location":"reference/SingleAddressWallet/#add_account","title":"add_account","text":"<pre><code>func add_account(account_index: int, password: String) -&gt; AddAccountResult\n</code></pre> <p>Adds an account to this wallet with the given index</p>"},{"location":"reference/SingleAddressWallet/#switch_account","title":"switch_account","text":"<pre><code>func switch_account(account: Account) -&gt; int\n</code></pre> <p>Switch to the account with the given <code>account_index</code>. It may fail if no such account exists. It returns the account index when it succeeds.</p>"},{"location":"reference/SingleAddressWallet/#accounts","title":"accounts","text":"<pre><code>func accounts() -&gt; Array[Account]\n</code></pre> <p>Return a list of accounts currently available in the wallet</p>"},{"location":"reference/SingleAddressWallet/#export","title":"export","text":"<pre><code>func export() -&gt; SingleAddressWalletResource\n</code></pre> <p>Export wallet to a resource.</p>"},{"location":"reference/SingleAddressWallet/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/SingleAddressWallet/#signdataresult","title":"SignDataResult","text":""},{"location":"reference/SingleAddressWallet/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/SingleAddressWallet/#value","title":"value","text":"<pre><code>var value: DataSignature\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/SingleAddressWallet/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/SingleAddressWallet/#addaccountresult","title":"AddAccountResult","text":""},{"location":"reference/SingleAddressWallet/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/SingleAddressWallet/#value_1","title":"value","text":"<pre><code>var value: Account\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/SingleAddressWallet/#error_1","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/SingleAddressWalletResource/","title":"SingleAddressWalletResource","text":""},{"location":"reference/SingleAddressWalletResource/#singleaddresswalletresource","title":"SingleAddressWalletResource","text":"<p>Extends: Resource</p>"},{"location":"reference/SingleAddressWalletResource/#description","title":"Description","text":"<p>This is a storage class used by [method SingleAddressWalletLoader.export].</p> <p>This is a storage class used by [method SingleAddressWalletLoader.export].</p>"},{"location":"reference/SingleAddressWalletResource/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/SingleAddressWalletResource/#encrypted_master_private_key","title":"encrypted_master_private_key","text":"<pre><code>@export var encrypted_master_private_key: PackedByteArray\n</code></pre>"},{"location":"reference/SingleAddressWalletResource/#accounts","title":"accounts","text":"<pre><code>@export var accounts: Array[AccountResource]\n</code></pre>"},{"location":"reference/SingleAddressWalletResource/#scrypt_log_n","title":"scrypt_log_n","text":"<pre><code>@export var scrypt_log_n: int\n</code></pre>"},{"location":"reference/SingleAddressWalletResource/#scrypt_r","title":"scrypt_r","text":"<pre><code>@export var scrypt_r: int\n</code></pre>"},{"location":"reference/SingleAddressWalletResource/#scrypt_p","title":"scrypt_p","text":"<pre><code>@export var scrypt_p: int\n</code></pre>"},{"location":"reference/SingleAddressWalletResource/#aes_iv","title":"aes_iv","text":"<pre><code>@export var aes_iv: PackedByteArray\n</code></pre>"},{"location":"reference/SingleAddressWalletResource/#salt","title":"salt","text":"<pre><code>@export var salt: PackedByteArray\n</code></pre>"},{"location":"reference/Transaction/","title":"Transaction","text":""},{"location":"reference/Transaction/#transaction","title":"Transaction","text":"<p>Extends: RefCounted</p>"},{"location":"reference/Transaction/#description","title":"Description","text":""},{"location":"reference/Transaction/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/Transaction/#transactionstatus","title":"TransactionStatus","text":"<pre><code>enum TransactionStatus{SUCCESS = 0, EVALUATION_ERROR = 1, DESERIALIZE_ERROR = 2}\n</code></pre>"},{"location":"reference/Transaction/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Transaction/#_init","title":"_init","text":"<pre><code>func _init(tx: _Transaction, input_utxos: Array[Utxo] = null) -&gt; Transaction\n</code></pre>"},{"location":"reference/Transaction/#bytes","title":"bytes","text":"<pre><code>func bytes() -&gt; PackedByteArray\n</code></pre>"},{"location":"reference/Transaction/#to_json","title":"to_json","text":"<pre><code>func to_json() -&gt; Dictionary\n</code></pre>"},{"location":"reference/Transaction/#add_signature","title":"add_signature","text":"<pre><code>func add_signature(signature: Signature) -&gt; void\n</code></pre> <p>Add a signature to the witness set</p>"},{"location":"reference/Transaction/#evaluate","title":"evaluate","text":"<pre><code>func evaluate(utxos: Array[Utxo]) -&gt; EvaluationResult\n</code></pre> <p>Try to evaluate the transaction</p>"},{"location":"reference/Transaction/#to_hash","title":"to_hash","text":"<pre><code>func to_hash() -&gt; TransactionHash\n</code></pre> <p>Get the unique hash of the transaction</p>"},{"location":"reference/Transaction/#input_utxos","title":"input_utxos","text":"<pre><code>func input_utxos() -&gt; Array[Utxo]\n</code></pre>"},{"location":"reference/Transaction/#outputs","title":"outputs","text":"<pre><code>func outputs() -&gt; Array[Utxo]\n</code></pre>"},{"location":"reference/Transaction/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/Transaction/#evaluationresult","title":"EvaluationResult","text":""},{"location":"reference/Transaction/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/Transaction/#value","title":"value","text":"<pre><code>var value: _EvaluationResult\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_ok</code>.</p>"},{"location":"reference/Transaction/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_err</code>.</p>"},{"location":"reference/TransactionHash/","title":"TransactionHash","text":""},{"location":"reference/TransactionHash/#transactionhash","title":"TransactionHash","text":"<p>Extends: RefCounted</p>"},{"location":"reference/TransactionHash/#description","title":"Description","text":"<p>The transaction hash is used to uniquely identify a transaction, which can be useful for many operations.</p> <p>The transaction hash is used to uniquely identify a transaction, which can be useful for many operations.</p>"},{"location":"reference/TransactionHash/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/TransactionHash/#status","title":"Status","text":"<pre><code>enum Status{SUCCESS = 0, INVALID_HASH = 1}\n</code></pre>"},{"location":"reference/TransactionHash/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/TransactionHash/#_init","title":"_init","text":"<pre><code>func _init(transaction_hash: _TransactionHash) -&gt; TransactionHash\n</code></pre>"},{"location":"reference/TransactionHash/#to_hex","title":"to_hex","text":"<pre><code>func to_hex() -&gt; String\n</code></pre> <p>Obtain a hex-encoding of the hash.</p>"},{"location":"reference/TransactionHash/#from_hex-static","title":"from_hex (static)","text":"<pre><code>func from_hex(hash: String) -&gt; FromHexResult\n</code></pre> <p>Tries to parse a TransactionHash.</p>"},{"location":"reference/TransactionHash/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/TransactionHash/#fromhexresult","title":"FromHexResult","text":""},{"location":"reference/TransactionHash/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/TransactionHash/#value","title":"value","text":"<pre><code>var value: TransactionHash\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result.is_ok.</p>"},{"location":"reference/TransactionHash/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on Result.tag or call Result._is_err.</p>"},{"location":"reference/TxBuilder/","title":"TxBuilder","text":""},{"location":"reference/TxBuilder/#txbuilder","title":"TxBuilder","text":"<p>Extends: RefCounted</p>"},{"location":"reference/TxBuilder/#description","title":"Description","text":"<p>The TxBuilder, which is a balanced and evaluated transaction that can be subsequently signed and submitted.</p> <p>The TxBuilder, which is a balanced and evaluated transaction that can be subsequently signed and submitted.</p>"},{"location":"reference/TxBuilder/#constants-descriptions","title":"Constants Descriptions","text":""},{"location":"reference/TxBuilder/#txbuilderstatus","title":"TxBuilderStatus","text":"<pre><code>enum TxBuilderStatus{SUCCESS = 0, BAD_PROTOCOL_PARAMETERS = 1, QUANTITY_EXCEEDS_MAXIMUM = 2, DESERIALIZE_ERROR = 3, BYRON_ADDRESS_UNSUPPORTED = 4, COULD_NOT_GET_KEY_HASH = 5, UNKNOWN_REDEEMER_INDEX = 6, UNEXPECTED_COLLATERAL_AMOUNT = 7, OTHER_ERROR = 8, CREATE_ERROR = 9, INVALID_DATA = 10, NO_UTXOS = 11, NO_CHANGE_ADDRESS = 12, COMPLETE_ERROR = 13}\n</code></pre>"},{"location":"reference/TxBuilder/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/TxBuilder/#_init","title":"_init","text":"<pre><code>func _init(provider: Provider, builder: _TxBuilder) -&gt; TxBuilder\n</code></pre> <p>You should not create a TxBuilder).</p>"},{"location":"reference/TxBuilder/#set_slot_config","title":"set_slot_config","text":"<pre><code>func set_slot_config(start_time: int, start_slot: int, slot_length: int) -&gt; TxBuilder\n</code></pre> <p>Set the slot configuration. This is automatically done on initialization, do not use unless you know what you are doing.</p>"},{"location":"reference/TxBuilder/#set_cost_models","title":"set_cost_models","text":"<pre><code>func set_cost_models(cost_models: CostModels) -&gt; TxBuilder\n</code></pre> <p>Set the cost models. This is automatically done on initialization, do not use unless you know what you are doing.</p>"},{"location":"reference/TxBuilder/#pay_to_address","title":"pay_to_address","text":"<pre><code>func pay_to_address(address: Address, coin: BigInt, assets: MultiAsset = null, datum: PlutusData = null, script_ref: PlutusScript = null, hash_datum: bool = false) -&gt; TxBuilder\n</code></pre> <p>Pay to a given [param address]. [param coin] specifies the quantity of lovelace to transfer, while the optional parameter [param assets] specifies any additional assets to transfer.[br] May optionally include a [param datum] and [param script_ref], and a flag [param hash_datum] determining whether the provided datum should be inline. NOTE: If [param assets] contains ADA it will be added to the amount set by [param coin].</p>"},{"location":"reference/TxBuilder/#pay_to_address_with_datum_hash","title":"pay_to_address_with_datum_hash","text":"<pre><code>func pay_to_address_with_datum_hash(address: Address, coin: BigInt, assets: MultiAsset, datum: PlutusData, script_ref: PlutusScript = null) -&gt; TxBuilder\n</code></pre> <p>Similar to [method pay_to_address], but it also takes a [param datum] argument that will be used to embed the datum hash in the transaction. [param datum] should be convertable to PlutusData.</p>"},{"location":"reference/TxBuilder/#mint_assets","title":"mint_assets","text":"<pre><code>func mint_assets(minting_policy_source: PlutusScriptSource, tokens: Array[MintToken], redeemer: PlutusData) -&gt; TxBuilder\n</code></pre> <p>Mint tokens with the given [param minting_policy] and using the a list of specs defined in [param tokens]. A [param redeemer] is also required for the minting policy.</p>"},{"location":"reference/TxBuilder/#mint_cip68_pair","title":"mint_cip68_pair","text":"<pre><code>func mint_cip68_pair(redeemer: PlutusData, conf: Cip68Config) -&gt; TxBuilder\n</code></pre> <p>Mint a pair of CIP68 user and reference tokens using the given [param redeemer] and minting configuration in [param conf].</p>"},{"location":"reference/TxBuilder/#mint_cip68_user_tokens","title":"mint_cip68_user_tokens","text":"<pre><code>func mint_cip68_user_tokens(redeemer: PlutusData, conf: Cip68Config, quantity: BigInt = null) -&gt; TxBuilder\n</code></pre> <p>Mint user tokens for a given [param conf]. This should generally be used for fungible tokens after the initial mint has been performed by [method mint_cip68_pair].</p>"},{"location":"reference/TxBuilder/#pay_cip68_ref_token","title":"pay_cip68_ref_token","text":"<pre><code>func pay_cip68_ref_token(address: Address, conf: Cip68Config) -&gt; TxBuilder\n</code></pre> <p>Pay the CIP68 reference token specified by [param minting_policy] and [param conf] to the given [param address].</p>"},{"location":"reference/TxBuilder/#pay_cip68_user_tokens","title":"pay_cip68_user_tokens","text":"<pre><code>func pay_cip68_user_tokens(address: Address, conf: Cip68Config, quantity: BigInt = null) -&gt; TxBuilder\n</code></pre> <p>Pay the CIP68 user tokens specified by [param minting_policy] and [param conf] to the given [param address].</p>"},{"location":"reference/TxBuilder/#pay_cip68_user_tokens_with_datum","title":"pay_cip68_user_tokens_with_datum","text":"<pre><code>func pay_cip68_user_tokens_with_datum(address: Address, datum: PlutusData, conf: Cip68Config, quantity: BigInt = null) -&gt; TxBuilder\n</code></pre> <p>Pay the CIP68 user tokens specified by [param minting_policy] and [param conf] to the given [param address]. The output will contain a [param datum].</p>"},{"location":"reference/TxBuilder/#collect_from","title":"collect_from","text":"<pre><code>func collect_from(utxos: Array[Utxo]) -&gt; TxBuilder\n</code></pre> <p>Consume all the [param utxos] specified.</p>"},{"location":"reference/TxBuilder/#collect_from_script","title":"collect_from_script","text":"<pre><code>func collect_from_script(plutus_script_source: PlutusScriptSource, utxos: Array[Utxo], redeemer: PlutusData) -&gt; TxBuilder\n</code></pre> <p>Consume all the [param utxos] locked by the [param plutus_script_source] using the provided [param redeemer].</p>"},{"location":"reference/TxBuilder/#set_change_address","title":"set_change_address","text":"<pre><code>func set_change_address(change_address: Address) -&gt; TxBuilder\n</code></pre> <p>When the transaction is balanced (usually when [method complete] is called), send any change to the provided [param change_address].</p>"},{"location":"reference/TxBuilder/#set_wallet","title":"set_wallet","text":"<pre><code>func set_wallet(wallet: OnlineWallet) -&gt; TxBuilder\n</code></pre> <p>Use the provided [param wallet] for balancing. This automatically sets the change address to that wallet's address.</p>"},{"location":"reference/TxBuilder/#valid_after","title":"valid_after","text":"<pre><code>func valid_after(time: int) -&gt; TxBuilder\n</code></pre> <p>Set the time in POSIX seconds after which the transaction is valid</p>"},{"location":"reference/TxBuilder/#valid_before","title":"valid_before","text":"<pre><code>func valid_before(time: int) -&gt; TxBuilder\n</code></pre> <p>Set the time in POSIX seconds before which the transaction is valid</p>"},{"location":"reference/TxBuilder/#add_required_signer","title":"add_required_signer","text":"<pre><code>func add_required_signer(pub_key_hash: PubKeyHash) -&gt; TxBuilder\n</code></pre> <p>Add a required signer constraint to the transaction.</p>"},{"location":"reference/TxBuilder/#add_reference_input","title":"add_reference_input","text":"<pre><code>func add_reference_input(utxo: Utxo) -&gt; TxBuilder\n</code></pre> <p>Add a [param utxo] as a reference input. This input will not be consumed but will be available in the script evaluation context.</p>"},{"location":"reference/TxBuilder/#balance","title":"balance","text":"<pre><code>func balance(utxos: Array[Utxo] = null) -&gt; BalanceResult\n</code></pre> <p>Only balance the transaction and return the result.[br]The resulting transaction will not have been evaluated and will have inaccurate script execution units, which may cause the transaction to fail at submission and potentially consume the provided collateral.[br][br]Do not use this function unless you know what you are doing.</p>"},{"location":"reference/TxBuilder/#complete","title":"complete","text":"<pre><code>func complete(utxos: Array[Utxo] = null) -&gt; CompleteResult\n</code></pre> <p>Attempts to balance and evaluate the transaction. The provided [param utxos] can be used for balancing the transaction.</p>"},{"location":"reference/TxBuilder/#create-static","title":"create (static)","text":"<pre><code>func create(provider: Provider) -&gt; CreateResult\n</code></pre> <p>TODO: This probably shouldn't be exposed. Create a TxBuilder object from a Provider. You should use [method Provider.new_tx] instead of this method, since that one will make sure to initialize other necessary fields.</p>"},{"location":"reference/TxBuilder/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/TxBuilder/#createresult","title":"CreateResult","text":""},{"location":"reference/TxBuilder/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/TxBuilder/#value","title":"value","text":"<pre><code>var value: TxBuilder\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_ok</code>.</p>"},{"location":"reference/TxBuilder/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_err</code>.</p>"},{"location":"reference/TxBuilder/#method-descriptions_1","title":"Method Descriptions","text":""},{"location":"reference/TxBuilder/#_init_1","title":"_init","text":"<pre><code>func _init(provider: Provider, res: _Result) -&gt; CreateResult\n</code></pre>"},{"location":"reference/TxBuilder/#balanceresult","title":"BalanceResult","text":""},{"location":"reference/TxBuilder/#property-descriptions_1","title":"Property Descriptions","text":""},{"location":"reference/TxBuilder/#value_1","title":"value","text":"<pre><code>var value: Transaction\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_ok</code>.</p>"},{"location":"reference/TxBuilder/#error_1","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_err</code>.</p>"},{"location":"reference/TxBuilder/#method-descriptions_2","title":"Method Descriptions","text":""},{"location":"reference/TxBuilder/#_init_2","title":"_init","text":"<pre><code>func _init(res: _Result) -&gt; BalanceResult\n</code></pre>"},{"location":"reference/TxBuilder/#completeresult","title":"CompleteResult","text":""},{"location":"reference/TxBuilder/#property-descriptions_2","title":"Property Descriptions","text":""},{"location":"reference/TxBuilder/#value_2","title":"value","text":"<pre><code>var value: TxComplete\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_ok</code>.</p>"},{"location":"reference/TxBuilder/#error_2","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_err</code>.</p>"},{"location":"reference/TxBuilder/#method-descriptions_3","title":"Method Descriptions","text":""},{"location":"reference/TxBuilder/#_init_3","title":"_init","text":"<pre><code>func _init(provider: Provider, res: _Result, wallet: OnlineWallet = null, input_utxos: Array[Utxo] = null) -&gt; CompleteResult\n</code></pre>"},{"location":"reference/TxBuilder/#minttoken","title":"MintToken","text":""},{"location":"reference/TxBuilder/#method-descriptions_4","title":"Method Descriptions","text":""},{"location":"reference/TxBuilder/#_init_4","title":"_init","text":"<pre><code>func _init(asset_name: AssetName, quantity: BigInt) -&gt; MintToken\n</code></pre>"},{"location":"reference/Utxo/","title":"Utxo","text":""},{"location":"reference/Utxo/#utxo","title":"Utxo","text":"<p>Extends: RefCounted</p>"},{"location":"reference/Utxo/#description","title":"Description","text":"<p>This class is used for representing Cardano's UTxOs, specifically their identifying attributes (TX hash and output index) but also other useful information such as the Address, [MultiAsset] value and datum information ([UtxoDatumInfo]) which can be very useful in TX tracking and building</p> <p>This class is used for representing Cardano's UTxOs, specifically their identifying attributes (TX hash and output index) but also other useful information such as the Address, [MultiAsset] value and datum information ([UtxoDatumInfo]) which can be very useful in TX tracking and building</p>"},{"location":"reference/Utxo/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/Utxo/#_init","title":"_init","text":"<pre><code>func _init(utxo: _Utxo) -&gt; Utxo\n</code></pre> <p>WARNING: This is for internal use. Use the [method create] method to safely construct a [Utxo].</p>"},{"location":"reference/Utxo/#tx_hash","title":"tx_hash","text":"<pre><code>func tx_hash() -&gt; TransactionHash\n</code></pre> <p>Get the TransactionHash.</p>"},{"location":"reference/Utxo/#datum_info","title":"datum_info","text":"<pre><code>func datum_info() -&gt; UtxoDatumInfo\n</code></pre> <p>Get any datum information contained in this output.</p>"},{"location":"reference/Utxo/#datum","title":"datum","text":"<pre><code>func datum() -&gt; PlutusData\n</code></pre>"},{"location":"reference/Utxo/#output_index","title":"output_index","text":"<pre><code>func output_index() -&gt; int\n</code></pre> <p>Get the index of this specific output in the transaction that produced it.</p>"},{"location":"reference/Utxo/#address","title":"address","text":"<pre><code>func address() -&gt; Address\n</code></pre> <p>Get the Address that locks this output.</p>"},{"location":"reference/Utxo/#coin","title":"coin","text":"<pre><code>func coin() -&gt; BigInt\n</code></pre> <p>Get the amount of Lovelace locked in this output.</p>"},{"location":"reference/Utxo/#assets","title":"assets","text":"<pre><code>func assets() -&gt; MultiAsset\n</code></pre> <p>Get all the assets (and respective quantities) locked in this output.</p>"},{"location":"reference/Utxo/#to_out_ref_string","title":"to_out_ref_string","text":"<pre><code>func to_out_ref_string() -&gt; String\n</code></pre>"},{"location":"reference/Utxo/#to_script_source","title":"to_script_source","text":"<pre><code>func to_script_source() -&gt; PlutusScriptSource\n</code></pre>"},{"location":"reference/Utxo/#create-static","title":"create (static)","text":"<pre><code>func create(tx_hash: String, output_index: int, address: String, coin: String, assets: Dictionary, datum_info: UtxoDatumInfo, script_ref: PlutusScript) -&gt; CreateResult\n</code></pre> <p>Construct a Utxo and other ancillary information.</p>"},{"location":"reference/Utxo/#sub-classes","title":"Sub-classes","text":""},{"location":"reference/Utxo/#createresult","title":"CreateResult","text":""},{"location":"reference/Utxo/#property-descriptions","title":"Property Descriptions","text":""},{"location":"reference/Utxo/#value","title":"value","text":"<pre><code>var value: Utxo\n</code></pre> <ul> <li>Getter: <code>@value_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_ok</code>.</p>"},{"location":"reference/Utxo/#error","title":"error","text":"<pre><code>var error: String\n</code></pre> <ul> <li>Getter: <code>@error_getter</code></li> </ul> <p>WARNING: This function may fail! First match on <code>tag</code> or call <code>is_err</code>.</p>"},{"location":"reference/Utxo/#method-descriptions_1","title":"Method Descriptions","text":""},{"location":"reference/Utxo/#_init_1","title":"_init","text":"<pre><code>func _init(results: ArrayResult) -&gt; CreateResult\n</code></pre>"},{"location":"reference/VoidData/","title":"VoidData","text":""},{"location":"reference/VoidData/#voiddata","title":"VoidData","text":"<p>Extends: RefCounted</p>"},{"location":"reference/VoidData/#description","title":"Description","text":""},{"location":"reference/VoidData/#method-descriptions","title":"Method Descriptions","text":""},{"location":"reference/VoidData/#to_data-static","title":"to_data (static)","text":"<pre><code>func to_data() -&gt; PlutusData\n</code></pre>"},{"location":"reference/VoidData/#from_data-static","title":"from_data (static)","text":"<pre><code>func from_data(v: Variant) -&gt; VoidData\n</code></pre>"}]}